C     Copyright (C) 2018 Jiabo Li, Brian Duke, and Roy McWeeny
C 
C     This program is free software: you can redistribute it and/or modify
C     it under the terms of the GNU General Public License as published by
C     the Free Software Foundation, either version 3 of the License, or
C     (at your option) any later version.
C 
C     This program is distributed in the hope that it will be useful,
C     but WITHOUT ANY WARRANTY; without even the implied warranty of
C     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C     GNU General Public License for more details.
C 
C     You should have received a copy of the GNU General Public License
C     along with this program.  If not, see <https://www.gnu.org/licenses/>.
C 
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Routines only used in the Gaussian VB2000 program.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE VBGAU
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C          Initial routine for Gaussian/VB2000 stand-alone version.
C
C     History:
C          Started in April 2012, but mostly developed in September 2012.
C          This version prepared for V2.8 in October, 2017.
C
C     Author:
C          Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      INTEGER*4 IVERS4, NLAB4, NAtom4, NBasi4, NBsUs4,
     $  IChar4, Multi4, NE4, Ln12L4, Len4L4
      INTEGER IVERS,I,LEN2
      LOGICAL GOTI4
C     LOGICAL EXISTS
      CHARACTER*10 TBUF 
      CHARACTER*30 MBUF,XBUF 
      CHARACTER*40 YBUF
      CHARACTER*64 LABFIL,GVERS,CBUF,FILE,FSTR2
C
      DOUBLE PRECISION C
      INTEGER IAN,ILSW,JCHARGE,MULTIP,NATOMT,NLAB,NBASIST
     &,NBSUSE,NE,LEN12L,LEN4L,MAXCEN
      PARAMETER (MAXCEN=200)
      COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
     &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      CHARACTER*16 BASNAM
      INTEGER LENBAS,ND,NF,NG,NP
      LOGICAL DS,DSP,LCC
      COMMON /BASIS/LENBAS,ND,NF,NG,NP,DS,DSP,LCC,BASNAM
C     BASNAM IS BASIS SET NAME FROM FORMATTED CHECKPOINT FILE, WHILE
C     BASNAME IS FROM #! LINE IN STAND-ALONE VERSION.
C
      WRITE(IOUT,1401)
C     Get filename of formatted checkpoint and unformatted dat file
      CALL GETARG(2,FSTR2)
      DO I=1,64
      IF(FSTR2(I:I).EQ.' ') THEN
         LEN2=I-1
         GOTO 1
      ENDIF
      ENDDO
 1    CONTINUE
C
C     OPEN GAUSSIAN OUTPUT FILE WITH INTEGRALS.
      FILE=FSTR2(1:LEN2)//'.dat'
      OPEN(UNIT=IU,FILE=FILE,STATUS='OLD',
     1  ACCESS='SEQUENTIAL',FORM="UNFORMATTED")
      WRITE(IOUT,'(" Using unformatted file:      ",A64)') FILE
C
C     Read first records of unformatted Gaussian output file.
C
C     Record 1:  Character*64 LabFil, Integer IVers, Integer NLab,
C                Character*64 GVers
C
C     A label for the file type, version number for the file format, 
C     number on general data records which follow and preceed the 
C     matrix elements, and the version of Gaussian which wrote the file.
C
      READ(IU) LABFIL, IVERS4, NLAB4, GVERS
      GOTI4 = IVERS4.eq.1.and.NLAB4.ge.7.and.NLAB4.le.100
      IF(GOTI4) THEN
        IVERS = IVERS4
        NLAB = NLAB4
      ELSE
        BACKSPACE IU
        READ(IU) LABFIL, IVERS, NLAB, GVERS
      ENDIF
C
C     Record 2:  Character*64 Title, Integer NAtoms, Integer NBasis, NBsUse,
C                ICharg, Multip, NE, Len12L, Len4L
C
C     The first 64 characters of the title section from the run which
C     created the file and the number of atoms and basis functions.
C     NBsUse is the number of linearly independent basis functions.
C     ICharg is the molecular charge, Multip the spin multiplicity
C     (1=singlet, etc.) and NE the number of electrons.  Len12L is
C     the number of bytes used for the integer labels for sparse 1d
C     and 2d matrices and Len4L is the number of bytes used for 4d
C     matrices (2e integrals).
C
      IF(GOTI4) THEN
        Read(IU) CBuf, NAtom4, NBasi4, NBsUs4, IChar4, Multi4, NE4,
     $    Ln12L4, Len4L4
        NATOMT = NAtom4
        NBASIST = NBasi4
        NBSUSE = NBsUs4
        JCHARGE = IChar4
        Multip = Multi4
        NE = NE4
        Len12L = Ln12L4
        Len4L = Len4L4
      ELSE
        READ(IU) CBUF,NATOMT,NBASIST,NBSUSE,JCHARGE,MULTIP,NE
      ENDIF
C
C     OPEN FORMATTED CHECKPOINT FILE
      FILE=FSTR2(1:LEN2)//'.fchk'
      OPEN(UNIT=ICHK,FILE=FILE,STATUS='OLD',
     1  ACCESS='SEQUENTIAL',FORM="FORMATTED")
C
      WRITE(IOUT,'(" Using checkpoint file:       ",A64)') FILE
      WRITE(IOUT,'(/," From unformatted file")')
      XBUF = LABFIL(1:30)
      MBUF = GVERS(1:30)
      YBUF = CBUF(1:40)
      WRITE(IOUT,1001) XBUF,IVERS,NLAB,GVERS,YBUF,LEN12L,LEN4L
      READ(ICHK,'(A64)') CBUF
      READ(ICHK,'(A10,A30,A30,A16)') TBUF,MBUF,XBUF,BASNAM
      YBUF = CBUF(1:40)
      WRITE(IOUT,'(/," From checkpoint file")')
      WRITE(IOUT,1002) YBUF,TBUF,MBUF,BASNAM
      IF(NBSUSE.NE.NBASIST) WRITE(IOUT,1004) NBASIST,NBSUSE
      IF (GotI4.and.Len12L.ne.4) then
        Write(IOut,1020)
        Stop
      ENDIF
C
C     The block below may be needed later if we can do OPT
C     and FREQ runs.
C     On first call of L511, create *.V99 and store whether
C     OPT or FREQ run.
C     FILE=FSTR(1:LENFIL)//'.V99'
C     INQUIRE(FILE=FILE,EXIST=EXISTS)
C     IF (.NOT.EXISTS) THEN
C       OPEN(UNIT=99,FILE=FILE,STATUS='UNKNOWN',
C    1    ACCESS='SEQUENTIAL',FORM="FORMATTED")
C       CALL FINDOPT(IOPT1,IOPT2)
C       WRITE(99,'(2I2)') IOPT1,IOPT2
C       CLOSE(99)
C     ENDIF
C
C     IF (ABS(E) .LE. 1.0D-8) THEN
C       WRITE(IOUT,1302)
C     ELSE
C       WRITE(IOUT,1300)
C     ENDIF
C     IF (Multip.gt.1) WRITE(IOUT,1301)
C1300 FORMAT(/," The properties output below uses the VB density,",/,
C    &  " in spite of the message saying it uses the SCF",/,
C    &  " density. The orbital energies of course, along with the",/,
C    &  " MO coefficients if pop=full is used, are HF. The",/,
C    &  " Mulliken population and moments are for the VB density.",/)
C1301 FORMAT(" VB Properties for Open Shell systems are only",/,
C    &       " obtained if Spin Densities are calculated with the",/,
C    &       " SPDEN keyword on the command line.")
C1302 FORMAT(/," This is a pure HF run, so the VB energy above is",/,
C    &  " zero and the properties output below uses the SCF density."/)
      RETURN
 1001 FORMAT(" File type label:             ",A30,/
     &       " File format version:         ",I12,/
     &       " Number on data records:      ",I12,/
     &       " Gaussian version:            ",A30,/ 
     &       " Gaussian job was titled:     ",A40,/
     &       " No. of bytes for 1-el index: ",I12,/
     &       " No. of bytes for 2-el index: ",I12)
 1002 FORMAT(" Gaussian job was titled:     ",A40,/
     &       " Gaussian job type:           ",A10,/
     &       " Gaussian job method:         ",A30,/
     &       " Gaussian job basis:          ",A24)
C1003 FORMAT(" NBSUSE=",I6," JCHARGE=",I6," MULTIP=",I6," NE=",I6
C    &," LEN12L=",I6," LEN4L=",I6)
 1004 FORMAT(/," Number of MOs reduced from",I5," to",I5)
 1020 Format(' RdMat is confused. GotI4 is true but LenL12 is not 4.')
 1401 FORMAT(
     1' *                                                            *'/
     1' *        ENTERING VB2000/GAUSSIAN STAND-ALONE PROGRAM        *'/
     1' *                                                            *'/
     1' **************************************************************')
      END
      SUBROUTINE VBGAU2
      IMPLICIT NONE
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
      CLOSE(ICHK)
      CLOSE(IU)
      WRITE(IOUT,99)
 99   FORMAT(/
     1' **************************************************************'/
     1' *                                                            *'/
     1' *                   ENDING GAUSSIAN VB2000                   *'/
     1' *                                                            *'/
     1' **************************************************************')
      RETURN
      END
      SUBROUTINE ABRTG(X)
      IMPLICIT NONE
      CHARACTER*(*) X
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
      WRITE(IOUT,1) X
 1    FORMAT(" ABORTING - ",A50)
      STOP
      END
      SUBROUTINE VBPROP(NBASIS,NSUB,MORBIT,RWRK)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  Function:
C            Properties of Wave Function (dipole moments).
C
C  Note:
C            Only used with Gaussian.
C
C  History:
C            First created in Sept. 2000.
C            Gamess code added, and Gaussian code modified in Dec. 2003.
C            More modifications for Gamess and Gaussian, Oct/Nov, 2004.
C            Gamess use removed as Gamess itself does this, 2006?
C            Removed use of COMMON /Mol/, September, 2010
C            Considerably modified for stand-alone Gaussian/VB2000,
C            September, 2012
C
C  Authors:
C            Jiabo Li
C            Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      INTEGER NBASIS,NSUB,MORBIT(*)
      DOUBLE PRECISION RWRK(*)
C
      INTEGER NBA2,IFLAG,LDMA,I,J,J1,J2,K,NOBADD1,LWK1
      INTEGER MWPROP,MW1PRP
      PARAMETER (MWPROP=100000,MW1PRP=150000)
      DOUBLE PRECISION W(MWPROP),W1(MW1PRP),A1,A2,ZERO
      DOUBLE PRECISION DIPDEN,TODEBYE,DELEC(3)
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      INTEGER NATOM,NELE,NSPIN,NBASISX,NATNUM,NATBAS,MAXCEN,MAXBFN
      DOUBLE PRECISION ENREP,XYZ
      PARAMETER (MAXCEN=200,MAXBFN=1350)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASISX,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      INTEGER NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     &LD2STA,LGDMP,N1DADD,N2DADD,NB1ADD,NB2ADD
      COMMON /ROTADD/NAOBAS,LAOBAS,NOCBAS,LOCBAS,ND1STA,ND2STA,LD1STA,
     & LD2STA,LGDMP,N1DADD(100),N2DADD(100),NB1ADD(100),NB2ADD(100)
C
      INTEGER IAN,ILSW,JCHARGE,MULTIP,NATOMT,NLAB,NBASIST
     &,NBSUSE,NE,LEN12L,LEN4L
      DOUBLE PRECISION C
      COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
     &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
C
      DOUBLE PRECISION ATMCHG
      COMMON /ATMCH/ ATMCHG(MAXCEN)
C
      DATA ZERO/0.0D0/
C
 1010 FORMAT(' ----------------------------------------------')
C1011 FORMAT(6F12.6)
C1013 FORMAT(/,' DIPOLE',I2,' MATRIX'/)
 1110 FORMAT(2X,'            X        Y        Z     Total ')
 1220 FORMAT(1X,'Density',4F9.4)
C
      NBA2=NBASIS*(NBASIS+1)/2
      IF(NBA2.GT.MWPROP) THEN
      WRITE(IOUT,'(/," BASIS SIZE TOO LARGE FOR DIPOLE CALCULATION")')
      RETURN
      ENDIF
C
      IF(JCHARGE.NE.0) RETURN
C     Dipole not calculated for ions.
C
      CALL DIPINTS(W1)
C
C     Calculate total density
C
      LDMA=1
      LWK1=LGDMP
      DO I=1,NBA2
        W(LDMA-1+I) = ZERO
      ENDDO
      IFLAG=1
      NOBADD1=NAOBAS
      DO K=1,NSUB
        CALL MATRAN2(MORBIT(K),NBASIS,RWRK(NOBADD1),RWRK(LWK1),
     &             RWRK(ND1STA-1+N1DADD(K)),W(LDMA),IFLAG)
        NOBADD1=NOBADD1+MORBIT(K)*NBASIS
      ENDDO

C
C     CALCULATE DENSITY DIPOLE OF VB WAVE FUNCTION
C
      DO I = 1, 3
        A1 = ZERO
        A2 = ZERO
        J1 = NBA2*(I-1)
        DO K = 1, NBA2
          A1 = A1 + W(LDMA+K-1)*W1(K+J1)
        ENDDO
C       Product of dipole integrals and density matrix terms
        J2 = 0
        DO  K = 1, NBASIS
          J2 = J2 + K
          A2 = A2 + W(LDMA+J2-1)*W1(J2+J1)
        ENDDO
C       Removes diagonal counted twice
        DELEC(I) = -2*A1 + A2
C       WRITE(IOUT,1013) I
C       WRITE(IOUT,1011) (W1(K+J1),K=1,NBA2)
      ENDDO
C
C     Add nuclear contribution
      DIPDEN=0.0D0
      TODEBYE=0.52917724924D0*4.803242D0
      DO I=1,3
        DO J=1,NATOM
          DELEC(I) = DELEC(I) + C(I,J)*ATMCHG(J)
        ENDDO
        DELEC(I)=DELEC(I)*TODEBYE
        DIPDEN=DIPDEN+DELEC(I)**2
      ENDDO
C
      DIPDEN=DSQRT(DIPDEN)
      WRITE(IOUT,*)
      WRITE(IOUT,1010)
      WRITE(IOUT,'(" Valence Bond Dipole moment (Debye)")')
      WRITE(IOUT,1010)
      WRITE(IOUT,1110)
      WRITE(IOUT,1220)(DELEC(I),I=1,3),DIPDEN
      WRITE(IOUT,1010)
C     NOCB=NB1ADD(NSUB+1)-1
      RETURN
      END
      SUBROUTINE DIPINTS(W1)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Removed from VBPROP, so that it can be used in CENTROID as well.
C
C     Brian Duke, August, 2013
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      DOUBLE PRECISION W1(*)
C
      CHARACTER*6 DIP
      CHARACTER*64 LABFIL,GVERS,CBUF
      INTEGER MAXCEN,IVERS,I,MAXNR,MAXBUF,MAXNTT
      PARAMETER (MAXNR=3,MAXBUF=8000,MAXNTT=1000000,MAXCEN=200)
      DOUBLE PRECISION DX(MAXNR,MAXBUF)
      LOGICAL DONE,EOF,LPRINT,LDIP
      INTEGER*4 ID4(4,MAXBUF)
      INTEGER ID(4,MAXBUF)
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      INTEGER IAN,ILSW,JCHARGE,MULTIP,NATOMT,NLAB,NBASIST
     &,NBSUSE,NE,LEN12L,LEN4L
      DOUBLE PRECISION C
      COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
     &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
C
      DATA DIP /'DIPOLE'/
C
C     Position file IU
      REWIND(IU)
      READ(IU) LABFIL, IVERS, NLAB, GVERS
      READ(IU) CBUF, NATOMT, NBASIST
C     Skip records to NLAB
      DO I = 3, NLAB
        READ(IU)
      END DO
C
C     Read Gaussian dipole integrals
C
      LPRINT = .FALSE.
C     LPRINT = .TRUE.
      EOF = .FALSE.
      DONE = .FALSE.
      LDIP = .TRUE.
      DO I = 1,100
        CALL READ1EGAU(IOUT,IU,CBuf,NBASIST,LEN12L,MAXBUF,ID,ID4,DX,
     &      MAXNTT,W1,DONE,EOF,LPRINT,LDIP)
        IF (CBUF(1:6).EQ.DIP) GOTO 40
        IF (DONE) THEN
          CALL ABRTG(" End of unformatted file seeking for DIPOLE")
        ENDIF
      ENDDO
 40   CONTINUE
      RETURN
      END

C     SUBROUTINE FINDOPT(IOPT1,IOPT2)
C
C     NOT NEEDED IN THIS VERSION
C
C     SETS IOPT1 = 1 IF "opt" FOUND ON COMMAND LINE
C     SETS IOPT1 = 2 IF "freq" FOUND ON COMMAND LINE
C     SETS IOPT2 = 1 IF "prop" FOUND ON COMMAND LINE
C     OTHERWISE SETS IOPT1 = 0 AND IOPT2 = 0
C     IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     CHARACTER*80 RECORD
C     CHARACTER*20 SP
C     CHARACTER*3 VOPT
C     CHARACTER*4 VFRQ,VPROP
C     INTEGER IN,IOUT,IPUNCH,IU,ICHK
C     COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C     DATA VOPT,VFRQ,VPROP/'OPT','FREQ','PROP'/
C     DATA SP/'                    '/
C     IOPT1 = 0
C     IOPT2 = 0
C     REWIND(IN)
C1    READ(IN,'(A80)',END=2) RECORD
C     IF (RECORD(1:1).NE."#") GOTO 1
C     GOTO 7
C6    READ(IN,'(A80)',END=2) RECORD
C7    CALL CONVCASE(RECORD,80,1)
C     IF (RECORD(1:20).EQ.SP) GOTO 2
C     DO J=1,77
C     IF (RECORD(J:J+3).EQ.VPROP) GOTO 5
C     ENDDO
C     GOTO 6
C5    IOPT2 = 1
C     GOTO 2
C2    REWIND(IN)
C11   READ(IN,'(A80)',END=22) RECORD
C     IF (RECORD(1:1).NE."#") GOTO 11
C     GOTO 17
C16   READ(IN,'(A80)',END=2) RECORD
C17   CALL CONVCASE(RECORD,80,1)
C     IF (RECORD(1:20).EQ.SP) GOTO 22
C     DO J=1,77
C     IF (RECORD(J:J+2).EQ.VOPT) GOTO 3
C     IF (RECORD(J:J+3).EQ.VFRQ) GOTO 4
C     ENDDO
C     GOTO 16
C3    IOPT1 = 1
C     GOTO 22
C4    IOPT1 = 2
C22   REWIND(IN)
C     RETURN
C     END
      SUBROUTINE GETCHK(A,N,I)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Finds character A of length N in formatted checkpoint file]
C     and returns its integer value I.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      CHARACTER*50 A
      INTEGER N,I
C
      CHARACTER*80 B
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      REWIND(ICHK)
 1    READ(ICHK,'(A80)') B
      IF(A(1:N).NE.B(1:N)) GOTO 1
      READ(B(51:61),'(I11)') I
      RETURN
      END
      SUBROUTINE GETCHK2(A,N,X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Finds character A of length N in formatted checkpoint file]
C     and returns its floating point value X.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      CHARACTER*40 A
      INTEGER N
      DOUBLE PRECISION X
C
      CHARACTER*80 B
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      REWIND(ICHK)
 1    READ(ICHK,'(A80)') B
      IF(A(1:N).NE.B(1:N)) GOTO 1
      READ(B(45:71),'(E27.15)') X
      RETURN
      END
      SUBROUTINE CHKDAT(C,NFORM,NDAT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Outputs values and aborts when NFORM from formatted checkpoint 
C     file is not identical to value NDAT from unformatted *.dat file.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      CHARACTER*6 C
      INTEGER NFORM,NDAT
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      WRITE(IOUT,1) C,NFORM,NDAT
      CALL ABRTG(' Error in either FCHK or DAT file')
 1    FORMAT(A6," is",I4," in FCHK and",I4," in DAT")
      RETURN
      END
      SUBROUTINE CONGAU1()
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  Function:
C            Reads the Gaussian formated *.fchk file to initialise. 
C
C  Note:
C            It reads some general information about a molecule from the
C            Gaussian formatted checkpoint file, sets up orbitals labels, etc.
C
C  History:
C            This is a heavily modifed version of a routine originally
C            written for the earlier Gaussian/VB2000 that created a
C            Gaussian link l511. This version is for a stand-alone
C            program that reads data from files generated by a G09 run.
C            First created in September 2012.
C
C  Authors:
C            Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      INTEGER ICHARGE,MULTI,NAE,NBE,I,J,MAXBFN
      DOUBLE PRECISION E(1000),BASIS(1000000)
      LOGICAL NOTEQ
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      CHARACTER*50 ASTRING,AZERO
      PARAMETER (MAXBFN=1350)
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
C     COMMON /CONG/ is for transfering information about the unformatted
C     input file from CONGAU1 to CONGAU2, and elsehere
      INTEGER IAN,ILSW,JCHARGE,MULTIP,NATOMT,NLAB,NBASIST
     &,NBSUSE,NE,LEN12L,LEN4L,MAXCEN
      DOUBLE PRECISION C
      PARAMETER (MAXCEN=200)
      COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
     &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
C
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      CHARACTER*16 BASNAM
      INTEGER LENBAS,ND,NF,NG,NP
      LOGICAL DS,DSP,LCC
      COMMON /BASIS/LENBAS,ND,NF,NG,NP,DS,DSP,LCC,BASNAM
C     BASNAM IS BASIS SET NAME FROM FORMATTED CHECKPOINT FILE, WHILE
C     BASNAME IS FROM #! LINE IN STAND-ALONE VERSION.
C
      DATA AZERO/'                                                  '/
C
      WRITE(IOUT,'(" COMMAND LINE #! BASIS SET NAME  = ",A20)') BASNAME
      WRITE(IOUT,'(" CHECKPOINT FILE BASIS SET NAME  = ",A16,/)') BASNAM
      DO I=1,30
      IF(BASNAM(I:I).EQ.' ') THEN
         LENBAS=I-1
         GOTO 1
      ENDIF
      ENDDO
 1    NOTEQ = .FALSE.
      ASTRING = AZERO
      ASTRING(1:15)="Number of atoms"
      CALL GETCHK(ASTRING,15,NATOM)
      ASTRING = AZERO
      ASTRING(1:25)="Number of basis functions"
      CALL GETCHK(ASTRING,25,NBASIS)
      ASTRING = AZERO
      ASTRING(1:25)="Number of alpha electrons"
      CALL GETCHK(ASTRING,25,NAE)
      ASTRING = AZERO
      ASTRING(1:24)="Number of beta electrons"
      CALL GETCHK(ASTRING,24,NBE)
      ASTRING = AZERO
      ASTRING(1:6)="Charge"
      CALL GETCHK(ASTRING,6,ICHARGE)
      ASTRING = AZERO
      ASTRING(1:12)="Multiplicity"
      CALL GETCHK(ASTRING,12,MULTI)
      ASTRING = AZERO
      ASTRING(1:4)="ILSW"
      CALL GETCHK(ASTRING,4,I)
      READ(ICHK,1201) (ILSW(J),J=1,I)
      NELE=NAE+NBE+ICHARGE
      WRITE(IOUT,900) ICHARGE,MULTI
      WRITE(IOUT,901) JCHARGE,MULTIP
      IF(ICHARGE.NE.JCHARGE.OR.MULTI.NE.MULTIP) THEN
        WRITE(IOUT,903)
        NOTEQ = .TRUE.
      ENDIF
      IF(MULTIP.LT.0) THEN
C     Negative multiplicity forces change of Charge/Multiplicity from
C     Gaussian values. Use new values.
        WRITE(IOUT,904)
        MULTIP = -MULTIP
        NBE = NAE - JCHARGE
      ELSE
C       Use values from Gaussian run.
        IF (NOTEQ) WRITE(IOUT,905)
        JCHARGE = ICHARGE
        MULTIP = MULTI
      ENDIF
      WRITE(IOUT,902) JCHARGE, MULTIP
C
  900 FORMAT(' Gaussian values: Charge =',I3,' Multiplicity =',I3)
  901 FORMAT(' Input values   : Charge =',I3,' Multiplicity =',I3)
  902 FORMAT(' Selected values: Charge =',I3,' Multiplicity =',I3,/)
  903 FORMAT(" Charge/Multiplicity in *.inp file not identical",/,
     &" to values in formatted checkpoint file.",/,
     &" This can be allowed, but is probably not intended.",/)
  904 FORMAT(" Multiplicity is negative, so allowing.")
  905 FORMAT(" Not allowing, continuing with Gaussian values.")
C
      NELE=NELE-JCHARGE
      NSPIN=NAE-NBE
      ASTRING = AZERO
      ASTRING(1:29)="Current cartesian coordinates"
      CALL GETCHK(ASTRING,29,I)
      READ(ICHK,1200) ((C(I,J),I=1,3),J=1,NATOM)
 1200 FORMAT(5E16.8)
      ASTRING = AZERO
      ASTRING(1:14)="Atomic numbers"
      CALL GETCHK(ASTRING,14,I)
      READ(ICHK,1201) (IAN(J),J=1,NATOM)
 1201 FORMAT(6I12)
C
      IF (NATOM.NE.NATOMT) CALL CHKDAT("NATOM ",NATOM,NATOMT)
      IF(NATOM.GE.MAXCEN) CALL SIZEABT(NATOM,MAXCEN,"      NATOM ",
     & "MAXCEN",IOUT,.TRUE.)
      IF (NBASIS.NE.NBASIST) CALL CHKDAT("NBASIS",NBASIS,NBASIST)
      IF(NBASIS.GE.MAXBFN) CALL SIZEABT(NBASIS,MAXBFN,"BASIS SIZE  ",
     &  "MAXBFN",IOUT,.TRUE.)
C
C     Now get MOs
      CALL RGAUMO(BASIS,E,NBASIS)
C
      RETURN
      END
      SUBROUTINE CONGAU2(S,H)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  Function:
C            Reads the Gaussian unformated *.dat file to initialise.
C
C  History:
C            This is a heavily modifed version of a routine originally
C            written for the earlier Gaussian/VB2000 that created a
C            Gaussian link l511. This version is for a stand-alone
C            program that reads data from files generated by a G09 run.
C            First created in September 2012.
C
C  Authors:
C            Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      DOUBLE PRECISION H(*),S(*)
C
      INTEGER I,J,K,J2,N2,IAO1E,NBA2,LLL,NALPHA,NBETA
      DOUBLE PRECISION ENERGY,R,XXX
      CHARACTER*2 ATMSYM(92)
      CHARACTER*4 CHAR4
      CHARACTER*4 SSYM(49),CSYM(31)
      CHARACTER*12 BFCH
      CHARACTER*50 ASTRING,AZERO
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      INTEGER IAN,ILSW,JCHARGE,MULTIP,NATOMT,NLAB,NBASIST
     &,NBSUSE,NE,LEN12L,LEN4L,MAXCEN
      DOUBLE PRECISION C
      PARAMETER (MAXCEN=200)
      COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
     &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
C
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS,MAXBFN
      DOUBLE PRECISION ENREP,XYZ
      CHARACTER*12 BFLABE
      CHARACTER*20 BASNAME
      PARAMETER (MAXBFN=1350)
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      INTEGER IOUTVB,LENFIL
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      INTEGER NUMD,NUMF
      COMMON /DORF/ NUMD,NUMF
C
      DOUBLE PRECISION ATMCHG
      COMMON /ATMCH/ ATMCHG(MAXCEN)
C
      INTEGER ISH,ISHT,INO,NSH,NSHELL
      CHARACTER*2 ILAB
      CHARACTER*4 ISSYM
      INTEGER MAXSHL
      PARAMETER (MAXSHL=500)
      COMMON /SEEBAS/ NSHELL,NSH,ISH(MAXSHL),ISHT(MAXSHL),INO(MAXBFN)
     &,ILAB(MAXBFN),ISSYM(MAXBFN)
C
      EQUIVALENCE (LLL,CHAR4)
      DATA AZERO/'                                                  '/
C     Symbols for spherical harmonics s to i.
      DATA SSYM/'   s','   x','   y','   z',
     &' d 0',' d+1',' d-1',' d+2',' d-2',
     &' f 0',' f+1',' f-1',' f+2',' f-2',' f+3',' f-3',
     &' g 0',' g+1',' g-1',' g+2',' g-2',' g+3',' g-3',' g+4',' g-4',
     &' h 0',' h+1',' h-1',' h+2',' h-2',' h+3',' h-3',' h+4',' h-4',
     &' h+5',' h-5',
     &' i 0',' i+1',' i-1',' i+2',' i-2',' i+3',' i-3',' i+4',' i-4',
     &' i+5',' i-5',' i+6',' i-6'/
C     Symbols for cartesians d to g only.
      DATA CSYM/'  xx','  yy','  zz','  xy','  xz','  yz',
     &' xxx',' yyy',' zzz',' xyy',' xxy',' xxz',' xzz',' yzz',' yyz',
     &' xyz','zzzz','yzzz','yyzz','yyyz','yyyy','xzzz','xyzz','xyyz',
     &'xyyy','xxzz','xxyz','xxyy','xxxz','xxxy','xxxx'/
      DATA ATMSYM/' H','He','Li','Be',' B',' C',' N',' O',' F','Ne',
     1            'Na','Mg','Al','Si',' P',' S','Cl','Ar',
     2            ' K','Ca','Sc','Ti',' V','Cr','Mn','Fe','Co',
     3            'Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr','Rb',
     4 'Sr',' Y','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In',
     5 'Sn','Sb','Te','I','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm',
     6 'Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu','Hf','Ta',
     7 ' W','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At',
     8 'Rn','Fr','Ra','Ac','Th','Pa',' U'/
C
C     WRITE(IOUT,'(" TO READ S & H")')
C     Skip records to NLAB
      DO I = 3, NLAB
        READ(IU)
      END DO
C
C     Get and store S and H
      CALL GETIOUNIT('IAO1E   ',IAO1E)
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(1)
      OPEN(UNIT=IAO1E,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      CALL RGAU1E(S,H)
      NBA2 = (NBASIS*(NBASIS+1))/2
      REWIND(IAO1E)
      WRITE(IAO1E)NBA2
      WRITE(IAO1E)(S(I),I=1,NBA2)
      WRITE(IAO1E)(H(I),I=1,NBA2)
      CLOSE(IAO1E)
C
C     May be needed if we can get OPT, FREQ or other PROP runs 
C
C     Check whether OPT, FREQ or PROP RUN
C     FILE=FSTR(1:LENFIL)//'.V99'
C     OPEN(UNIT=99,FILE=FILE,STATUS='OLD',
C    1  ACCESS='SEQUENTIAL',FORM="FORMATTED")
C     READ(99,'(2I2)') IOPT1,IOPT2
C     CLOSE(99)
C     IF (IOPT1.EQ.1) THEN
C      IMACRO = 24
C      NEPS = 7
C      WRITE(IOUT,'(/," MACROITERATION CONVERGENCE TOLERANCE TIGHTENED",
C    & /," TO 10.00**(-7) FOR GEOMETRY OPTIMIZATION.")')
C     ENDIF
C     IF (IOPT1.EQ.2) THEN
C      IMACRO = 36
C      NEPS = 8
C      WRITE(IOUT,'(/," MACROITERATION CONVERGENCE TOLERANCE TIGHTENED",
C    & /," TO 10.00**(-8) FOR FREQUENCY RUN.")')
C     ENDIF
C
C     Get 5D/6D and 7F/10F
      ASTRING = AZERO
      ASTRING(1:24)="Highest angular momentum"
      CALL GETCHK(ASTRING,24,K)
      NUMD = ILSW(2)
      NUMF = ILSW(16)
      IF (K.LT.2) NUMD = 1
      IF (K.LT.3) NUMF = 1
      IF (K.GE.2) THEN 
        IF (NUMD.EQ.0) THEN 
          WRITE(IOUT,'(" Spherical harmonic D orbitals are used")')
        ELSE
          WRITE(IOUT,'(" Cartesian D orbitals are used")')
        ENDIF
      ENDIF
      IF (K.GE.3) THEN 
        IF (NUMF.EQ.0) THEN
          WRITE(IOUT,'(" Spherical harmonic F orbitals are used")')
        ELSE
          WRITE(IOUT,'(" Cartesian F orbitals are used")')
        ENDIF
      ENDIF
C    &   " OPEN SHELL SYSTEMS AT THIS TIME.",/)
      WRITE(IOUT,'(/," Cartesian coordinates of atoms in Angstrom"/
     &           " ------------------------------------------"/
     &           "                 X         Y         Z   "/)')
      K = 0
      DO I=1,NATOM
        NATNUM(I)=IAN(I)
        NATBAS(I)=0
        XXX=IAN(I)
        ATMCHG(I)=XXX
        DO J=1,3
          XYZ(J,I)=C(J,I)*0.52917724924D0
        END DO
        WRITE(IOUT,1110) ATMSYM(IAN(I)),XXX,(XYZ(J,I),J=1,3)
      END DO
 1110 FORMAT(1X,A5,F5.1,3F10.6)
      WRITE(IOUT,'(" ------------------------------------------"/)')
C
C     Check validity of Icharge and Multiplicity
C
      NALPHA = (NELE + MULTIP - 1)/2
      NBETA = (NELE - MULTIP + 1)/2
      IF ((NALPHA + NBETA).NE.NELE) THEN
        WRITE(IOUT,1400)
 1400   FORMAT(" Multiplicity and molecular Charge are not compatible",
     &  /," Please check and correct them. Exiting!",/)
        CALL ABRTG(" Incorrect multiplicity or molecular Charge")
      ENDIF
      ASTRING = AZERO
      ASTRING(1:10)="SCF Energy"
      CALL GETCHK2(ASTRING,10,ENERGY)
      WRITE(IOUT,1120) ENERGY
 1120 FORMAT(' HARTREE-FOCK ENERGY FROM GAUSSIAN RUN = ',F20.12,/)
      if (MULTIP.GT.1) WRITE(IOUT,1130)
 1130 FORMAT(' THE ABOVE OPEN SHELL ENERGY FROM GAUSSIAN IS A ROHF',/
     1      ,' ENERGY AND IS DIFFERENT FROM THE ENERGY GIVEN BY A',/
     2      ,' PURE VB2000 RUN. IT IS MUCH LOWER. IT GIVES A GOOD',/
     3      ,' STARTING POINT FOR THE VB RUN AND GIVES THE SAME VB',/
     4      ,' ENERGY AS A PURE VB2000 RUN.',/)
C
C     Get BFLABE labels in VB2000 form. OK for 5D and 6D. 
C     OK for 7F for f, g, h and i, 10F is OK only for f and g.
      ASTRING = AZERO
      ASTRING(1:27)="Number of contracted shells"
      CALL GETCHK(ASTRING,27,NSHELL)
      ASTRING = AZERO
      ASTRING(1:17)="Shell to atom map"
      CALL GETCHK(ASTRING,17,I)
      READ(ICHK,1201) (ISH(J),J=1,NSHELL)
      ASTRING = AZERO
      ASTRING(1:11)="Shell types"
      CALL GETCHK(ASTRING,11,NSHELL)
      READ(ICHK,1201) (ISHT(J),J=1,NSHELL)
      I = 1
      NSH = 0
      DO J=1,NSHELL
        NSH = NSH + 1
        IF(ISHT(J).EQ.0) THEN
C         S SHELL
          INO(I) = ISH(J)
          ISSYM(I)=SSYM(1)
          I = I + 1
        ENDIF
        IF(ISHT(J).EQ.1) THEN
C         P SHELL
          DO K=1,3
            INO(I) = ISH(J)
            ISSYM(I)=SSYM(K+1)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).EQ.-1) THEN
C         L SHELL
          NSH = NSH + 1
          DO K=1,4
            INO(I) = ISH(J)
            ISSYM(I)=SSYM(K)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).EQ.2) THEN
C         D CARTESIANS SHELL
          DO K=1,6
            INO(I) = ISH(J)
            ISSYM(I)=CSYM(K)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).EQ.-2) THEN
C         D SHERICAL HARMONICS SHELL
          DO K=1,5
            INO(I) = ISH(J)
            ISSYM(I)=SSYM(K+4)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).EQ.3) THEN
C         F CARTESIANS SHELL
          DO K=1,10
            INO(I) = ISH(J)
            ISSYM(I)=CSYM(K+6)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).EQ.-3) THEN
C         F SHERICAL HARMONICS SHELL
          DO K=1,7
            INO(I) = ISH(J)
            ISSYM(I)=SSYM(K+9)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).GE.4) THEN
C         G CARTESIANS SHELL
          DO K=1,15
            INO(I) = ISH(J)
            ISSYM(I)=CSYM(K+16)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).EQ.-4) THEN
C         G SHERICAL HARMONICS SHELL
          DO K=1,9
            INO(I) = ISH(J)
            ISSYM(I)=SSYM(K+16)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).GE.5) THEN
C         H CARTESIANS SHELL
          CALL ABRTG(" H & I CARTESIANS NOT YET ALLOWED")
C         DO K=1,21
C           INO(I) = ISH(J)
C           ILAB(I) = ATMSYM(IAN(INO(I)))
C           ISSYM(I)=CSYM(K+31)
C           I = I + 1
C         ENDDO  
        ENDIF
        IF(ISHT(J).EQ.-5) THEN
C         H SHERICAL HARMONICS SHELL
          DO K=1,11
            INO(I) = ISH(J)
            ISSYM(I)=SSYM(K+25)
            I = I + 1
          ENDDO  
        ENDIF
        IF(ISHT(J).EQ.-6) THEN
C         I SHERICAL HARMONICS SHELL
          DO K=1,13
            INO(I) = ISH(J)
            ISSYM(I)=SSYM(K+36)
            I = I + 1
          ENDDO  
        ENDIF
      ENDDO
      DO I=1,NBASIS
        BFCH='            '
        LLL=INO(I)
        ILAB(I) = ATMSYM(IAN(LLL))
        NATBAS(LLL) = NATBAS(LLL) + 1
        WRITE(BFCH(1:3),'(I3)') LLL
        BFCH(5:6)=ILAB(I)
        BFCH(7:8)='  '
        BFCH(9:12)=ISSYM(I)
        BFLABE(I)=BFCH
      ENDDO
      ENREP = 0.0D0
      N2 = NATOM - 1 
      DO J=1,N2
        J2 = J + 1
        DO I=J2,NATOM
          R = 0.0D0
          DO K=1,3
            R = R + (C(K,J) - C(K,I))**2
          ENDDO
          R = SQRT(R)
          ENREP = ENREP + IAN(J)*IAN(I)/R
        ENDDO
      ENDDO
      WRITE(IOUT,'(" Nuclear repulsion energy =",F18.10,/)') ENREP
      WRITE(IOUT,120) NBASIS
 120  FORMAT(' BASIS SET SIZE = ',I4,/)
 1201 FORMAT(6I12)
      RETURN
      END
      SUBROUTINE RGAU1E(S,H)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Reads S and H matrices from unformatted *.dat file. 
C
C     Sept. 2012. Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      DOUBLE PRECISION S(*),H(*)
C
      INTEGER MAXBUF,MAXNTT,MAXNR,I
      PARAMETER (MAXBUF=8000,MAXNR=3,MAXNTT=1000000)
      INTEGER*4 ID4(4,MaxBuf)
      INTEGER ID(4,MAXBUF)
      LOGICAL DONE,EOF,LPRINT,LDIP
      DOUBLE PRECISION DX(MAXNR,MAXBUF), X(MAXNTT)
      CHARACTER*8 SOVER,HOVER
      CHARACTER*64 CBUF
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      INTEGER IAN,ILSW,JCHARGE,MULTIP,NATOMT,NLAB,NBASIST
     &,NBSUSE,NE,LEN12L,LEN4L,MAXCEN
      DOUBLE PRECISION C
      PARAMETER (MAXCEN=200)
      COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
     &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
C
      DATA SOVER/"OVERLAP "/
      DATA HOVER/"CORE HAM"/
C
C     Determines printing of integrals as read.
      LPRINT = .FALSE.
C     LPRINT = .TRUE.
      LDIP = .FALSE.
      EOF = .FALSE.
      DONE = .FALSE.
      DO I = 1,100
        CALL READ1EGAU(IOUT,IU,CBuf,NBASIST,LEN12L,MAXBUF,ID,ID4,DX,
     &      MAXNTT,S,DONE,EOF,LPRINT,LDIP)
        IF (CBUF(1:8).EQ.SOVER) GOTO 40
        IF (DONE) THEN
          CALL ABRTG(" End of unformatted file seeking for OVERLAP")
        ENDIF
      ENDDO
 40   CONTINUE
      EOF = .FALSE.
      DONE = .FALSE.
      DO I = 1,100
        CALL READ1EGAU(IOUT,IU,CBuf,NBASIST,LEN12L,MAXBUF,ID,ID4,DX,
     &      MAXNTT,H,DONE,EOF,LPRINT,LDIP)
        IF (CBUF(1:8).EQ.HOVER) GOTO 50
        IF (DONE) THEN
          CALL ABRTG(" End of unformatted file seeking for HAMILTONIAN")
        ENDIF
      ENDDO
 50   CONTINUE
      DO I = 1,100
        CALL READ1EGAU(IOUT,IU,CBuf,NBASIST,LEN12L,MAXBUF,ID,ID4,DX,
     &      MAXNTT,X,DONE,EOF,LPRINT,LDIP)
        IF (DONE) RETURN
      ENDDO
      WRITE(IOUT,'(" IN SUBROUTINE RGAU1E(S,H) -4")')
      RETURN
      END
      SUBROUTINE GET2E(G)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Function:
C               Gets 2-electron integrals for Gaussian from unformatted
C               *.dat file and writes them out to disc for latter use,
C               using READ2EGAU, which is miodified routine from Mike
C               Frisch.
C
C     History:
C               First created in Sept. 2012.
C
C     Author:
C               Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      DOUBLE PRECISION G(*)
C
      INTEGER MAXBUF,MAXNR
      CHARACTER*64 CBUF
      LOGICAL EOF
      PARAMETER (MAXBUF=8000,MAXNR=3)
      INTEGER ID(4,MAXBUF)
      INTEGER*2 ID2(4,MAXBUF)
      INTEGER*4 ID4(4,MAXBUF)
      DOUBLE PRECISION DX(MAXNR,MAXBUF)
C
      DOUBLE PRECISION C
      INTEGER IAN,ILSW,JCHARGE,MULTIP,NATOMT,NLAB,NBASIST
     &,NBSUSE,NE,LEN12L,LEN4L,MAXCEN
      PARAMETER (MAXCEN=200)
      COMMON /CONG/ C(3,MAXCEN),IAN(MAXCEN),ILSW(100),JCHARGE,MULTIP
     &,NATOMT,NLAB,NBASIST,NBSUSE,NE,LEN12L,LEN4L
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      EOF = .FALSE.
      CALL READ2EGAU(IOUT,IU,EOF,LEN12L,LEN4L,CBUF,MAXBUF,
     $  MAXNR,ID,ID2,ID4,DX,G)
      RETURN
      END
      SUBROUTINE PUT2E(G,INDIJ,INDKL,NWORD,LBUFF,IUNIT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Writes buffer of packed integrals.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      DOUBLE PRECISION G(*)
      INTEGER INDIJ(*),INDKL(*),I,NWORD,LBUFF,IUNIT
C
      WRITE(IUNIT) (G(I),I=1,LBUFF),(INDIJ(I),I=1,LBUFF),
     &             (INDKL(I),I=1,LBUFF),NWORD
      RETURN
      END
      SUBROUTINE IJKLG0(IAO2E,GG,II,JJ,KK,LL,NINT)
      IMPLICIT NONE
      DOUBLE PRECISION GG(*)
      INTEGER II(*),JJ(*),KK(*),LL(*),NINT
C
      INTEGER I,IAO2E,IREC,INDIJ(20000),INDKL(20000)
C
C     INTEGER IN,IOUT,IPUNCH,IU,ICHK
C     COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      INTEGER LBUFF
      COMMON /INTS/ LBUFF
C
      READ(IAO2E)(GG(I),I=1,LBUFF),(INDIJ(I),I=1,LBUFF),
     &                             (INDKL(I),I=1,LBUFF),NINT
      IF(NINT.GT.LBUFF) CALL ABRTG(" NINT > LBUFF in IJKLG0")
      DO 50 IREC=1,NINT
         CALL DECODEIJ(INDIJ(IREC),II(IREC),JJ(IREC))
         CALL DECODEIJ(INDKL(IREC),KK(IREC),LL(IREC))
   50 CONTINUE
      RETURN
      END
      SUBROUTINE RGAU2E(IO2E,G)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Reads 2-electron integrals from local file.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      INTEGER IO2E
      DOUBLE PRECISION G(*)
C
      INTEGER INDEXIJ(10000),INDEXKL(10000),NREC,NINT,IREC,I,IJKL
      DOUBLE PRECISION GG(10000)
C
C     INTEGER IN,IOUT,IPUNCH,IU,ICHK
C     COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      INTEGER LBUFF
      COMMON /INTS/ LBUFF
C
C     WRITE(IOUT,'(" IN RGAU2E: LBUFF =",I6," IAO2E =",I6)')LBUFF,IO2E
      REWIND(IO2E)
      NREC  = 0
   32 NREC  = NREC+1
      READ(IO2E)(GG(I),I=1,LBUFF),(INDEXIJ(I),I=1,LBUFF),
     &          (INDEXKL(I),I=1,LBUFF),NINT
      IF(NINT.GT.LBUFF) CALL ABRTG(" NINT > LBUFF in RGAU2E")
      DO 50 IREC=1,NINT
        IJKL = INDEXIJ(IREC)*(INDEXIJ(IREC)-1)/2 + INDEXKL(IREC)
        G(IJKL) = GG(IREC)
   50 CONTINUE
      IF(NINT.NE.LBUFF) GOTO 201
      GOTO 32
  201 RETURN
      END
      SUBROUTINE RGAUMO(BASIS,E,NBASIS)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Reads the MOs. New version for SO Gaussian/VB2000
C     Sept. 2012. Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      DOUBLE PRECISION BASIS(*),E(*)
      INTEGER NBASIS
C
      INTEGER I,J,NDIM,K,IOHFORB
      CHARACTER*50 ASTRING,AZERO
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      INTEGER IOUTVB,LENFIL
      CHARACTER*3 FUNIT(10)
      CHARACTER*64 FSTR,RWFFILE,INTFILE,LOCFILE,FILE
      COMMON /FILNAM/ IOUTVB,FSTR,RWFFILE,INTFILE,LOCFILE,LENFIL,FUNIT
C
      DATA AZERO/'                                                  '/
      ASTRING = AZERO
      ASTRING(1:22)="Alpha Orbital Energies"
      CALL GETCHK(ASTRING,22,NDIM)
      READ(ICHK,1200) (E(J),J=1,NDIM)
      ASTRING = AZERO
      ASTRING(1:21)="Alpha MO coefficients"
      CALL GETCHK(ASTRING,21,K)
      READ(ICHK,1200) (BASIS(J),J=1,K)
C
C     Now write them out. 
      CALL GETIOUNIT('IOHFORB  ',IOHFORB)
      FILE=FSTR(1:LENFIL)//'.'//FUNIT(3)
      OPEN(UNIT=IOHFORB,FILE=FILE,STATUS='UNKNOWN',
     1ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
      REWIND(IOHFORB)
      WRITE(IOHFORB)NDIM,(2,I=1,NDIM)
      WRITE(IOHFORB)(E(J),J=1,NDIM)
      I = NDIM*NBASIS
      WRITE(IOHFORB)(BASIS(J),J=1,I)
      CLOSE(IOHFORB)
      RETURN
 1200 FORMAT(5E16.8)
      END
      SUBROUTINE BASISG(NAT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     Gets basis set information for visualisation routines in
C     VB2000/GAUSSIAN09 stand-alone version.
C
C     Extensive modification of earlier Gaussian98 BASISG
C
C     Written: Brian J. Duke, December 2012.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      INTEGER NAT
C
      INTEGER KKK,NPRIM,NP,I,J,JJJ,K,LL,JJ
      INTEGER IPS(1000),JSHT(1000),JPS(1000)
      INTEGER MAXSHL,MAXCEN,MAXPRM,MAXBFN
      LOGICAL SPLIT
      CHARACTER*50 ASTRING,AZERO
      DOUBLE PRECISION CPR(1000),CCC(1000),CLC(1000)
      PARAMETER (MAXSHL=500,MAXCEN=200,MAXPRM=15,MAXBFN=1350)
      DIMENSION JJ(MAXSHL)
C
      DOUBLE PRECISION COEFF,XEXP
      LOGICAL LOGMOL
      CHARACTER*1 SYM
      INTEGER NF,KATOM,IMOL,JMOL
      COMMON /SEEING/ XEXP(MAXSHL,MAXPRM),COEFF(MAXSHL,MAXPRM)
     &,NF(MAXSHL),KATOM(MAXCEN),IMOL,JMOL,LOGMOL,SYM(MAXSHL)
C
      INTEGER NSHELL,NSH,ISH,ISHT,INO
      CHARACTER*2 ILAB
      CHARACTER*4 ISSYM
      COMMON /SEEBAS/ NSHELL,NSH,ISH(MAXSHL),ISHT(MAXSHL),INO(MAXBFN)
     &,ILAB(MAXBFN),ISSYM(MAXBFN)
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
      DATA AZERO/'                                                  '/
C
      DO I=1,NAT
        KATOM(I)=0
      ENDDO
C
      ASTRING = AZERO
      ASTRING(1:26)="Number of primitive shells"
      CALL GETCHK(ASTRING,26,NPRIM)
C
      ASTRING = AZERO
      ASTRING(1:30)="Number of primitives per shell"
      CALL GETCHK(ASTRING,30,NP)
      IF(NP.NE.NSHELL) CALL ABRTG(" Number of primitives per shell") 
      READ(ICHK,1300) (IPS(J),J=1,NP)
C
      ASTRING = AZERO
      ASTRING(1:19)="Primitive exponents"
      CALL GETCHK(ASTRING,19,NP)
      IF(NP.NE.NPRIM) CALL ABRTG(" Primitive exponents")
      READ(ICHK,1200) (CPR(J),J=1,NP)
C
      ASTRING = AZERO
      ASTRING(1:24)="Contraction coefficients"
      CALL GETCHK(ASTRING,24,NP)
      IF(NP.NE.NPRIM) CALL ABRTG(" Contraction coefficients")
      READ(ICHK,1200) (CCC(J),J=1,NP)
C
      SPLIT = .FALSE.
      DO I=1,NSHELL
        KATOM(ISH(I)) = KATOM(ISH(I)) + 1
        IF (ISHT(I).EQ.-1) THEN
           SPLIT = .TRUE.
           KATOM(ISH(I)) = KATOM(ISH(I)) + 1
        ENDIF
      ENDDO
C
      IF (SPLIT) THEN
        ASTRING = AZERO
        ASTRING(1:31)="P(S=P) Contraction coefficients"
        CALL GETCHK(ASTRING,31,NP)
        IF(NP.NE.NPRIM) CALL ABRTG(" P(S=P) Contraction coefficients")
        READ(ICHK,1200) (CLC(J),J=1,NP)
      ENDIF
C
      J=0
      DO I=1,NSHELL
        J=J+1
        IF(ISHT(I).EQ.-1) THEN
          JSHT(J) = 0
          JPS(J) = IPS(I)
          J=J+1
          JSHT(J) = -1
          JPS(J) = IPS(I)
        ELSE
          JSHT(J) = ISHT(I)
          JPS(J) = IPS(I)
        ENDIF
      ENDDO
      J = 1
      JJJ = 0
C     J,K,KKK is position in CPR and CCC
C     JJJ is position in XEXP and COEFF - spliting SP
      DO I=1,NSH
        SPLIT=.FALSE.
        IF (JSHT(I).EQ.-1) SPLIT=.TRUE.
        IF(.NOT.SPLIT.AND.I.GT.1) J = J + JPS(I-1)
        IF (JSHT(I).EQ.0) LL = 1
        IF (ABS(JSHT(I)).EQ.1) LL = 3
        IF (JSHT(I).EQ.2) LL = 6
        IF (JSHT(I).EQ.-2) LL = 5
        IF (JSHT(I).EQ.3) LL = 10
        IF (JSHT(I).EQ.-3) LL = 7
        IF (JSHT(I).EQ.4) LL = 15
        IF (JSHT(I).EQ.-4) LL = 9
        IF (JSHT(I).EQ.5) LL = 21
        IF (JSHT(I).EQ.-5) LL = 11
        IF (JSHT(I).EQ.6) LL = 28
        IF (JSHT(I).EQ.-6) LL = 13
        JJ(I) = LL
C       LOOP OVER NUMBER OF FNs IN SHELL
C       LOOP OVER NUMBER OF PRIMITIVES
        JJJ = JJJ + 1
        NF(JJJ) = JPS(I)
        IF(SPLIT) THEN
          DO K=1,JPS(I)
            KKK = J+K-1
            XEXP(JJJ,K) = CPR(KKK)
            COEFF(JJJ,K) = CLC(KKK)
          ENDDO
        ELSE
          DO K=1,JPS(I)
            KKK = J+K-1
            XEXP(JJJ,K) = CPR(KKK)
            COEFF(JJJ,K) = CCC(KKK)
          ENDDO
        ENDIF
      ENDDO
      IF(JJJ.NE.NSH) CALL ABRTG(" JJJ not equal to NSH")
      DO I=1,NSH
        IF (JJ(I).EQ.1) SYM(I)="s"
        IF (JJ(I).EQ.3) SYM(I)="p"
        IF (JJ(I).EQ.6) SYM(I)="d"
        IF (JJ(I).EQ.5) SYM(I)="d"
        IF (JJ(I).EQ.10) SYM(I)="f"
        IF (JJ(I).EQ.7) SYM(I)="f"
        IF (JJ(I).EQ.15) SYM(I)="g"
        IF (JJ(I).EQ.9) SYM(I)="g"
        IF (JJ(I).EQ.21) SYM(I)="h"
        IF (JJ(I).EQ.11) SYM(I)="h"
        IF (JJ(I).EQ.28) SYM(I)="i"
        IF (JJ(I).EQ.13) SYM(I)="i"
      ENDDO
      RETURN
 1200 FORMAT(5E16.8)
 1300 FORMAT(6I12)
      END
      SUBROUTINE ORBPTG(SUM,C1,C2,XE,XX,YY,ZZ,JT,IT,M,N)
C#######################################################################
C
C     Common routine for finally creating CUBE, GRID, LINE and
C     DENSCUBE points.
C
C     This routine is only for Gaussian version with both cartesians 
C     and pure spherical harmonics.
C
C#######################################################################
      IMPLICIT NONE
      INTEGER MAXCEN,MAXEXP
      PARAMETER (MAXCEN=200,MAXEXP=4400)
      INTEGER JT(MAXEXP),IT(MAXEXP),M,N,J
      DOUBLE PRECISION SUM,C1(3,MAXCEN),C2(MAXEXP),XE(MAXEXP),
     &  XX,YY,ZZ,R,R2,X,Y,Z,XTEMP,SS
      DO J=M,N
        X = XX - C1(1,JT(J))
        Y = YY - C1(2,JT(J))
        Z = ZZ - C1(3,JT(J))
        R2 = X*X + Y*Y + Z*Z
        R = SQRT(R2)
        XTEMP = EXP(-XE(J)*R*R)
        IF(IT(J).LE.84)
     &  GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
     &   19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,
     &   36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,
     &   56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
     &   75,76,77,78,79,80,81,82,83,84) IT(J)
C       PURE SPHERICAL HARMONICS ARE ONLY USED IN THE GAUSSIAN VERSION,
        IF(IT(J).GT.100) CALL SPHERGAU(IT(J),C2(J),SS,X,Y,Z)
        GOTO 99
C
C       S ORBITALS
 1      SS = C2(J) 
        GOTO 99
C       P ORBITALS
 2      SS = C2(J) * X 
        GOTO 99
 3      SS = C2(J) * Y 
        GOTO 99
 4      SS = C2(J) * Z 
        GOTO 99
C       D ORBITALS
 5      SS = C2(J) * X * X 
        GOTO 99
 6      SS = C2(J) * Y * Y 
        GOTO 99
 7      SS = C2(J) * Z * Z 
        GOTO 99
 8      SS = C2(J) * X * Y 
        GOTO 99
 9      SS = C2(J) * X * Z 
        GOTO 99
 10     SS = C2(J) * Y * Z 
        GOTO 99
C       F ORBITALS
 11     SS = C2(J) * X * X * X 
        GOTO 99
 12     SS = C2(J) * Y * Y * Y 
        GOTO 99
 13     SS = C2(J) * Z * Z * Z 
        GOTO 99
 14     SS = C2(J) * Y * Y * X 
        GOTO 99
 15     SS = C2(J) * X * X * Y 
        GOTO 99
 16     SS = C2(J) * X * X * Z 
        GOTO 99
 17     SS = C2(J) * Z * Z * X 
        GOTO 99
 18     SS = C2(J) * Z * Z * Y 
        GOTO 99
 19     SS = C2(J) * Y * Y * Z 
        GOTO 99
 20     SS = C2(J) * X * Y * Z 
        GOTO 99
C       G ORBITALS
 21     SS = C2(J) *Z*Z*Z*Z 
        GOTO 99
 22     SS = C2(J) *Z*Z*Z*Y 
        GOTO 99
 23     SS = C2(J) *Y*Y*Z*Z 
        GOTO 99
 24     SS = C2(J) *Y*Y*Y*Z 
        GOTO 99
 25     SS = C2(J) *Y*Y*Y*Y 
        GOTO 99
 26     SS = C2(J) *Z*Z*Z*X 
        GOTO 99
 27     SS = C2(J) *Z*Z*X*Y 
        GOTO 99
 28     SS = C2(J) *Y*Y*X*Z 
        GOTO 99
 29     SS = C2(J) *Y*Y*Y*X 
        GOTO 99
 30     SS = C2(J) *X*X*Z*Z 
        GOTO 99
 31     SS = C2(J) *X*X*Y*Z 
        GOTO 99
 32     SS = C2(J) *X*X*Y*Y 
        GOTO 99
 33     SS = C2(J) *X*X*X*Z 
        GOTO 99
 34     SS = C2(J) *X*X*X*Y 
        GOTO 99
 35     SS = C2(J) *X*X*X*X 
        GOTO 99
C       H ORBITALS
 36     SS = C2(J) *Z*Z*Z*Z*Z 
        GOTO 99
 37     SS = C2(J) *Z*Z*Z*Z*Y 
        GOTO 99
 38     SS = C2(J) *Z*Z*Z*Y*Y 
        GOTO 99
 39     SS = C2(J) *Y*Y*Y*Z*Z 
        GOTO 99
 40     SS = C2(J) *Y*Y*Y*Y*Z 
        GOTO 99
 41     SS = C2(J) *Y*Y*Y*Y*Y 
        GOTO 99
 42     SS = C2(J) *Z*Z*Z*Z*X 
        GOTO 99
 43     SS = C2(J) *Z*Z*Z*X*Y 
        GOTO 99
 44     SS = C2(J) *Y*Y*Z*Z*X 
        GOTO 99
 45     SS = C2(J) *Y*Y*Y*X*Z 
        GOTO 99
 46     SS = C2(J) *Y*Y*Y*Y*X 
        GOTO 99
 47     SS = C2(J) *Z*Z*Z*X*X 
        GOTO 99
 48     SS = C2(J) *X*X*Z*Z*Y 
        GOTO 99
 49     SS = C2(J) *X*X*Y*Y*Z 
        GOTO 99
 50     SS = C2(J) *Y*Y*Y*X*X 
        GOTO 99
 51     SS = C2(J) *X*X*X*Z*Z 
        GOTO 99
 52     SS = C2(J) *X*X*X*Y*Z 
        GOTO 99
 53     SS = C2(J) *X*X*X*Y*Y 
        GOTO 99
 54     SS = C2(J) *X*X*X*X*Z 
        GOTO 99
 55     SS = C2(J) *X*X*X*X*Y 
        GOTO 99
 56     SS = C2(J) *X*X*X*X*X 
        GOTO 99
C       I ORBITALS
 57     SS = C2(J) *Z*Z*Z*Z*Z*Z 
        GOTO 99
 58     SS = C2(J) *Z*Z*Z*Z*Z*Y 
        GOTO 99
 59     SS = C2(J) *Z*Z*Z*Z*Y*Y 
        GOTO 99
 60     SS = C2(J) *Y*Y*Y*Z*Z*Z 
        GOTO 99
 61     SS = C2(J) *Y*Y*Y*Y*Z*Z 
        GOTO 99
 62     SS = C2(J) *Y*Y*Y*Y*Y*Z 
        GOTO 99
 63     SS = C2(J) *Y*Y*Y*Y*Y*Y 
        GOTO 99
 64     SS = C2(J) *Z*Z*Z*Z*Z*X 
        GOTO 99
 65     SS = C2(J) *Z*Z*Z*Z*X*Y 
        GOTO 99
 66     SS = C2(J) *Z*Z*Z*Y*Y*X 
        GOTO 99
 67     SS = C2(J) *Y*Y*Y*Z*Z*X 
        GOTO 99
 68     SS = C2(J) *Y*Y*Y*Y*X*Z 
        GOTO 99
 69     SS = C2(J) *Y*Y*Y*Y*Y*X 
        GOTO 99
 70     SS = C2(J) *Z*Z*Z*Z*X*X 
        GOTO 99
 71     SS = C2(J) *Z*Z*Z*X*X*Y 
        GOTO 99
 72     SS = C2(J) *X*X*Y*Y*Z*Z 
        GOTO 99
 73     SS = C2(J) *Y*Y*Y*X*X*Z 
        GOTO 99
 74     SS = C2(J) *Y*Y*Y*Y*X*X 
        GOTO 99
 75     SS = C2(J) *X*X*X*Z*Z*Z 
        GOTO 99
 76     SS = C2(J) *X*X*X*Z*Z*Y 
        GOTO 99
 77     SS = C2(J) *X*X*X*Y*Y*Z 
        GOTO 99
 78     SS = C2(J) *X*X*X*Y*Y*Y 
        GOTO 99
 79     SS = C2(J) *X*X*X*X*Z*Z 
        GOTO 99
 80     SS = C2(J) *X*X*X*X*Y*Z 
        GOTO 99
 81     SS = C2(J) *X*X*X*X*Y*Y 
        GOTO 99
 82     SS = C2(J) *X*X*X*X*X*Z 
        GOTO 99
 83     SS = C2(J) *X*X*X*X*X*Y 
        GOTO 99
 84     SS = C2(J) *X*X*X*X*X*X 
 99     CONTINUE
        SUM = SUM + SS * XTEMP
      ENDDO
      RETURN
      END
      SUBROUTINE SPHCONST
C
C     SET UP COMMON OF SQRT CONSTANTS TO AVOID EVALUATING AT EVERY POINT
C
      IMPLICIT NONE
      DOUBLE PRECISION HALF,THR,FOUR,FIVE,X10,X20,SQ2,SQ3,SQ5,SQ6,SQ7
     & ,SQ10,SQ14,SQ21,SQ30,SQ35,SQ70,SQ105,FACTSQ
      COMMON /SPHCON/HALF,THR,FOUR,FIVE,X10,X20,SQ2,SQ3,SQ5,SQ6,SQ7
     &,SQ10,SQ14,SQ21,SQ30,SQ35,SQ70,SQ105,FACTSQ(7)
      HALF = 0.5D0
      THR = 3.0D0
      FOUR = 4.0D0
      FIVE = 5.0D0
      X10 = 1.0D1
      X20 = 2.0D1
      SQ2 = SQRT(2.0D0)
      SQ3 = SQRT(THR)
      SQ5 = SQRT(FIVE)
      SQ6 = SQRT(6.0D0)
      SQ7 = SQRT(7.0D0)
      SQ10 = SQRT(X10)
      SQ14 = SQRT(1.4D1)
      SQ21 = SQRT(2.1D1)
      SQ30 = SQRT(3.0D1)
      SQ35 = SQRT(3.5D1)
      SQ70 = SQRT(7.0D1)
      SQ105 = SQRT(1.05D2)
      RETURN
      END
      SUBROUTINE SPHERGAU(IT,C2,SS,X,Y,Z)
C
C     CALLED FROM ORBPTG TO GET VALUE OF PURE SPHERICAL HARMONIC
C     BASIS FUNCTION CONTRIBUTION TO CUBE, GRID, LINE AND 
C     DENSCUBE POINTS.
C
      IMPLICIT NONE
      INTEGER IT
      DOUBLE PRECISION C2,SS,X,Y,Z
C
      DOUBLE PRECISION HALF,THR,FOUR,FIVE,X10,X20,SQ2,SQ3,SQ5,SQ6,SQ7
     & ,SQ10,SQ14,SQ21,SQ30,SQ35,SQ70,SQ105,FACTSQ
      COMMON /SPHCON/HALF,THR,FOUR,FIVE,X10,X20,SQ2,SQ3,SQ5,SQ6,SQ7
     &,SQ10,SQ14,SQ21,SQ30,SQ35,SQ70,SQ105,FACTSQ(7)
C
C     THESE SPHERICAL HARMONIC FORMULA ARE TAKEN FROM HORTON
C http://theochem.github.io/horton/tut_gaussian_basis.html#introduction
C
      SS = 0.0D0
      GOTO (101,102,103,104,105,106,107,108,109,110,111,112,113,
     & 114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
     & 129,130,131,132,133,134,135,136,137,138,139,140,141,142,
     & 143,144,145) IT-100
C     D ORBITALS FOR GAUSSIAN SHERICAL HARMONICS
C     NO NEED HERE TO ADD IN NORMALISATION
 101  SS = C2 * (Z * Z - HALF * (X * X + Y * Y)) 
        RETURN
 103  SS = C2 * X * Z 
        RETURN
 105  SS = C2 * Y * Z 
        RETURN
 104  SS = C2 * HALF * SQ3 * (X*X - Y*Y) 
        RETURN
 102  SS = C2 * X * Y 
C
C     NORMALISATION MUST BE ADDED IN HERE AS IT IS DIFFERENT FOR
C     DIFFERENT TERMS IN EACH ORBITAL
C
C     F ORBITALS FOR GAUSSIAN SHERICAL HARMONICS 
C
 106  SS = C2 * (FACTSQ(4) * Z * Z  - 
     & FACTSQ(3)*THR * SQ5 * (X*X + Y*Y)/X10) * Z 
        RETURN
C
 107  SS = C2 * (FACTSQ(3) * (SQ30 * Z *Z / FIVE - SQ30 * Y * Y / X20)
     &  - FACTSQ(4) * SQ6 * X * X / FOUR) * X 
        RETURN
C
 108  SS = C2 * (FACTSQ(3) * (SQ30 * Z * Z / FIVE - SQ6 * Y *Y / FOUR) 
     & - FACTSQ(4) * SQ30 * X * X / X20) * X 
        RETURN
C
 109  SS = C2 * FACTSQ(3) * HALF * SQ3 * (X * X - Y * Y) * Z 
        RETURN
C
 110  SS = C2 * X * Y * Z 
        RETURN
C
 111  SS = C2 * HALF * HALF *(FACTSQ(4) * SQ10 * X * X 
     &  - FACTSQ(3) * THR * SQ2 * Y * Y) * X 
        RETURN
C
 112  SS = C2 * HALF * HALF * (FACTSQ(3) *THR * SQ2 * X * X
     &  - FACTSQ(4) * SQ10 * Y * Y) * Y 
        RETURN
C
C     G ORBITALS FOR GAUSSIAN SHERICAL HARMONICS
C
 113  SS = C2 * (FACTSQ(5)*(Z*Z*Z*Z + 0.375D0 * (X*X*X*X + Y*Y*Y*Y)) 
     & + FACTSQ(3) * FACTSQ(3) * SQ105 * THR *
     & (HALF * HALF * X*X*Y*Y - Z * Z * (X*X + Y*Y)) / 3.5D1)
        RETURN
C
 114  SS = C2 * X * Z * (FACTSQ(4) * SQ70 * Z * Z / 7.0D0 - 3.0D0 * 
     & (FACTSQ(3) * SQ14 * Y * Y  + FACTSQ(4) * SQ70 * X * X) / 2.8D1)
        RETURN
C
 115  SS = C2 * Y * Z * (FACTSQ(5) * SQ70 * Z * Z / 7.0D0 - 3.0D0 * 
     & (FACTSQ(3) * SQ14 * X * X  + FACTSQ(4) * SQ70 * Y * Y) / 2.8D1)
        RETURN
C
 116  SS = C2 * HALF * (HALF * SQ5 * FACTSQ(5) * 
     & (Y * Y * Y * Y - X * X * X * X) + FACTSQ(3) * FACTSQ(3) *
     &  THR * SQ21 * (X * X * Z * Z - Y * Y * Z * Z) /7.0D0)
        RETURN
C
 117  SS = C2 * X * Y * (FACTSQ(3) * THR *  Z * Z - 
     & SQ35 * FACTSQ(4) * HALF * (X * X + Y * Y) / 7.0D0)
         RETURN
C
 118  SS = C2 * HALF * HALF * X * Z * 
     & (FACTSQ(4) * SQ10 * X * X - FACTSQ(3) * THR * SQ2 * Y * Y)
        RETURN
C
 119  SS = C2 * HALF * HALF * Y * Z * 
     & (FACTSQ(3) * SQ10 * X * X - FACTSQ(4) * THR * SQ2 * Y * Y)
        RETURN
C
 120  SS = C2 * HALF * HALF * (SQ35 * FACTSQ(5) * HALF * 
     & (X * X * X * X + Y * Y * Y * Y) -
     & THR * SQ3 * FACTSQ(3) * FACTSQ(3) * X * X * Y * Y)
        RETURN
C
 121  SS = C2 * HALF * SQ5 * FACTSQ(4) * (X * X - Y * Y) * X * Y 
        RETURN
C
C       H ORBITALS FOR GAUSSIAN SHERICAL HARMONICS. NEED TO DO
C       BUT THE FOLLOWING WILL ADD ZERO IN.
 122    GOTO 99
 123    GOTO 99
 124    GOTO 99
 125    GOTO 99
 126    GOTO 99
 127    GOTO 99
 128    GOTO 99
 129    GOTO 99
 130    GOTO 99
 131    GOTO 99
 132    GOTO 99
C       I ORBITALS FOR GAUSSIAN SHERICAL HARMONICS. NEED TO DO
C       BUT THE FOLLOWING WILL ADD ZERO IN.
 133    GOTO 99
 134    GOTO 99
 135    GOTO 99
 136    GOTO 99
 137    GOTO 99
 138    GOTO 99
 139    GOTO 99
 140    GOTO 99
 141    GOTO 99
 142    GOTO 99
 143    GOTO 99
 144    GOTO 99
 145    GOTO 99
 99     CONTINUE
      RETURN
      END
      SUBROUTINE CENTROID(VX,W1,WRK,L1,L2,LNA)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     FOR ALL VB ORBITALS CALCULATES AND WRITES THE CENTROIDS OF CHARGE
C     AND THE ORBITAL EXTENT.
C
C     Modified from GAMESS version, August, 2013.
C
C     Author Brian Duke
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT NONE
      INTEGER ITEMP,MAXCEN,MAXBFN,MAXEXT,MAXGRP,L1,L2,LNA,I,J,LCENT,
     & ICENT,ICURSOR,LENW,LENBUF,IOK,KI,KJ,K,MWPROP,MW1PRP,NDIST,IDIST
      LOGICAL TOCALC,GETORB
      PARAMETER (MAXCEN=200,MAXBFN=1350)
      CHARACTER*80 BUFF,WORD,VBPATH
      PARAMETER (MWPROP=100000,MW1PRP=150000)
      DOUBLE PRECISION W1(MW1PRP),DIST(5),ZERO,BOHR,SUM
      DOUBLE PRECISION VX(L1,LNA),WRK(L1,L1),CC(3,MAXCEN)
      DIMENSION ITEMP(99),IDIST(5)
      PARAMETER (ZERO=0.0D+00)
C
      CHARACTER*20 BASNAME
      CHARACTER*12 BFLABE
      INTEGER NATOM,NELE,NSPIN,NBASIS,NATNUM,NATBAS
      DOUBLE PRECISION ENREP,XYZ
      COMMON /GENINF/NATOM,NELE,NSPIN,NBASIS,NATNUM(MAXCEN),
     & NATBAS(MAXCEN),ENREP,XYZ(3,MAXCEN),BFLABE(MAXBFN),BASNAME
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      INTEGER IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     & IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,NEXTRA
      COMMON /IOUNIT/IAO1E,IAO2E,IOHFORB,IOVBORB,IVBO2E,IOMAP,IOHES,
     &               IOVBOLIB,IOENGI,IOTEMP,IOTEMPA,IOTEMPB,VBPATH
C
      INTEGER NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,LPTALL,LHYBRD
     &,MELE,MSPIN,MNORBIT,MLORBIT,MWIN,MSTR,METHOD,IBASIS,NOCC,NOBIAS
     &,NEPS,NVIR,NOTROT,LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS
     &,KEY,IMOLDEN
      PARAMETER (NEXTRA=20,MAXEXT=MAXBFN+NEXTRA,MAXGRP=49)
      COMMON /GENCTL/NSUB,IMACRO,IPNT,MROT,ICON,LFROZN,LCIONLY,IMOLDEN,
     &LPTALL,LHYBRD,MELE(MAXGRP),MSPIN(MAXGRP),MNORBIT(MAXGRP),
     &MLORBIT(MAXGRP),MWIN(MAXGRP),MSTR(MAXGRP),METHOD(MAXGRP),
     &IBASIS(MAXEXT),NOCC(MAXEXT),NOBIAS,NEPS,NVIR,NOTROT(5000),
     &LTEST,IRESTART,IGUESSREAD,MTHEORY,NGPF,MBASIS,KEY(MAXGRP)
C
      DATA BOHR/0.52917724924D0/
C
C     TOCALC local function
      TOCALC(J,LCENT,ICENT) = ((METHOD(IBASIS(J)).GT.1.AND.
     &  METHOD(IBASIS(J)).LT.99.AND.LCENT.LT.3)
     &  .OR. (LCENT.EQ.2).OR.(LCENT.EQ.3.AND.IBASIS(J).EQ.ICENT))
C
C     Options:-
C
C     Default: Centroids printed for all groups with method > 1 (i.e VB).
C     If the run is a reactor, optimisation or frequency run, centroids
C     are printed for the first step only.
C     LCENT = 1 'none':       No centroids printed.
C     LCENT = 2 'hf':         Add Method 1 (HF) to default VB orbitals.
C     LCENT = 3 'group n':    Print centroids only for group n. This can
C                             only appear once.
C     LCENT = 4 'orbitals n': Print centroids only for n (n < 100) orbitals
C                             in a list on the following line, e.g.:-
C              orbitals 3
C              4 5 6
C
C     Optionally followed by 'distances n" and then a line giving n atoms.
C     Distances of the centroids from these atoms will then be printed.
C     The default is to use the first few atoms up to a maximum of 5.
C
      IF(L2.GT.MWPROP) THEN
        WRITE(IOUT,
     &    '(/," BASIS SIZE TOO LARGE FOR CENTROID CALCULATION")')
        RETURN
      ENDIF
C
      NDIST=0
      LCENT = 0
      ICENT=0
      K=0
      WRITE(IOUT,9)
      CALL LOCTOR(IOENGI,'$CENTROID',9,IOK,0)
      IF(IOK.EQ.1) THEN
 21     K=K+1
        READ(IOENGI,'(A80)') BUFF
        IF (BUFF(1:20).EQ.'                    ') THEN
          IF(K.EQ.1) GOTO 23
          GOTO 22
        ENDIF
        CALL CONVCASE(BUFF,80,1)
        ICURSOR=1
        LENW=0
        LENBUF=80
        WORD = ' '
        CALL READWDM(BUFF,WORD,LENW,ICURSOR,LENBUF)
        IF(WORD.EQ.'NONE') THEN 
          WRITE(IOUT,11)
          RETURN
        ENDIF
        IF (WORD.EQ.'DISTANCES') THEN
          IF(LCENT.EQ.0) WRITE(IOUT,16)
          CALL READNUM(BUFF,NDIST,LENW,ICURSOR,LENBUF)
          IF (NDIST.GT.5) GOTO 9998
          READ(IOENGI,*,ERR=9998)(IDIST(J),J=1,NDIST)
          WRITE(IOUT,17) NDIST,(IDIST(J),J=1,NDIST)
          GOTO 22
        ENDIF
        IF (WORD.EQ.'HF') THEN
          LCENT = 2
          WRITE(IOUT,12)
        ELSE IF (WORD.EQ.'GROUP') THEN
          LCENT = 3
          CALL READNUM(BUFF,ICENT,LENW,ICURSOR,LENBUF)
          WRITE(IOUT,13) ICENT
        ELSE IF (WORD.EQ.'ORBITALS') THEN
          LCENT = 4
          CALL READNUM(BUFF,ICENT,LENW,ICURSOR,LENBUF)
          READ(IOENGI,*,ERR=9999)(ITEMP(J),J=1,ICENT)
          WRITE(IOUT,14) ICENT,(ITEMP(J),J=1,ICENT)
        ELSE
          WRITE(IOUT,'(" IMPROPER $CENTROID OPTION FOUND")')
          RETURN
        ENDIF
        GOTO 21
      ENDIF
 23   WRITE(IOUT,16)
 22   WRITE(IOUT,4)
C
      DO J=1,NATOM
        DO I=1,3
          CC(I,J) = XYZ(I,J)
        ENDDO
        WRITE(IOUT,1) J,NATNUM(J),(CC(I,J),I=1,3)
      END DO
C
C     GET DIPOLE INTEGRALS
C     WRITE(IOUT,'(/" DIPOLE ",3I2)') I
      WRITE(IOUT,'(/)')
      CALL DIPINTS(W1)
C
      DO I = 1,3
C       PUT INTEGRALS INTO FULL MATRIX
        K=1
        DO KI=1,L1
          DO KJ=1,KI
            WRK(KI,KJ)=W1(L2*(I-1)+K)
            K=K+1
          END DO
        END DO
        DO KI=1,L1
          DO KJ=1,KI
          WRK(KJ,KI)=WRK(KI,KJ)
          END DO
        END DO
C       DO KI=1,L1
C         WRITE(IOUT,'(7F10.6)') (WRK(KI,KJ),KJ=1,L1)
C       END DO
C       GET CENTROID
        DO J = 1,LNA
          IF(TOCALC(J,LCENT,ICENT).OR.GETORB(J,ICENT,ITEMP,LCENT)) THEN
            SUM=ZERO
            DO KI=1,L1
              DO KJ=1,L1
                SUM=SUM + VX(KI,J)*VX(KJ,J)*WRK(KI,KJ)
              END DO
            END DO
            CC(I,J)=SUM*BOHR
          ENDIF
        END DO
      END DO
C
      IF(NDIST.EQ.0) THEN
        NDIST=NATOM
        IF(NATOM.GT.5) NDIST=5
        DO I=1,NDIST
          IDIST(I)=I
        ENDDO
      ENDIF
      WRITE(IOUT,2) NDIST
      WRITE(IOUT,5)
      WRITE(IOUT,3) (IDIST(I),I=1,NDIST)
      DO J=1,LNA
        IF(TOCALC(J,LCENT,ICENT).OR.GETORB(J,ICENT,ITEMP,LCENT)) THEN
          DO K=1,NDIST
            SUM = ZERO
            DO I=1,3
              SUM = SUM + (CC(I,J) - XYZ(I,IDIST(K)))**2
            ENDDO
            DIST(K) = SQRT(SUM)
          ENDDO
          WRITE(IOUT,1) J,IBASIS(J),(CC(I,J),I=1,3),(DIST(K),K=1,NDIST)
        ENDIF
      END DO
      RETURN
C
 1    FORMAT(1X,I4,6X,I4,5X,8F9.4)
 2    FORMAT(/,' CENTROIDS OF CHARGE FOR EACH VB GROUP & DISTANCES'
     & ,' FROM',I2,' ATOMS')
 3    FORMAT(' Orbital#   Group#',7X,'X',8X,'Y',8X,'Z',5I9)
 4    FORMAT(/,' NORMAL GAUSSIAN MOLECULAR GEOMETRY',//,
     & '  Atom#   ATOMIC NO.',5X,'X',8X,'Y',8X,'Z')
 5    FORMAT(/,50X,'DISTANCES FROM ATOMS')
 9    FORMAT(/,' CALCULATION OF POSITION OF VB ORBITALS')
 11   FORMAT(/," $CENTROID found to not print centroids")
 12   FORMAT(/," $CENTROID found to add HF group centroids")
 13   FORMAT(/," $CENTROID found for GROUP",I3)
 14   FORMAT(/," $CENTROID found for",I3," orbitals - ",99I3)
 16   FORMAT(/," DEFAULT CENTROIDS")
 17   FORMAT(/,I2," DISTANCES found for atoms - ",99I3)
C
 9998 WRITE(IOUT,'("INCORRECT DISTANCES DATA")')
      RETURN
 9999 WRITE(IOUT,'("INCORRECT ORBITAL DATA")')
      RETURN
      END
      LOGICAL FUNCTION GETORB(M,N,I,L)
      IMPLICIT NONE
      INTEGER I(99),J,M,N,L
      GETORB = .FALSE.
      IF (L.NE.4) RETURN
      DO J=1,N
        IF(M.EQ.I(J)) THEN
          GETORB = .TRUE.
          RETURN
        ENDIF
      ENDDO
      RETURN
      END
      SUBROUTINE GETVBOLIB(K,BAS,IOLVBO,MAXATNO)
      IMPLICIT NONE
      CHARACTER*80 BAS
      INTEGER K,IOLVBO,MAXATNO
C
      INTEGER I,J,LB
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      CHARACTER*16 BASNAM
      INTEGER LENBAS,ND,NF,NG,NP
      LOGICAL DS,DSP,LCC
      COMMON /BASIS/LENBAS,ND,NF,NG,NP,DS,DSP,LCC,BASNAM
C     BASNAM IS BASIS SET NAME FROM FORMATTED CHECKPOINT FILE, WHILE
C     BASNAME IS FROM #1 LINE IN STAND-ALONE VERSION.
C
C     DEFAULT ADDITIONS
      ND = 0
      NF = 0
      NG = 0
      NP = 0
      DS = .FALSE.
      DSP = .FALSE.
      LCC = .FALSE.
C     DEFAULT FOR ALTERING VBOLIB
      MAXATNO=1
C
      IF(BASNAM(1:3).EQ.'D95') THEN
        BAS='D95'
        K=3
        RETURN
      ENDIF
      IF(BASNAM(1:5).EQ.'MIDIx') THEN
        BAS='MIDIX'
        K=5
        RETURN
      ENDIF
      IF(BASNAM(1:3).EQ.'STO') THEN
C       ANY VALUE OF n in STO-nG ALLOWED, BUT ONLY STO-3G IS DOCUMENTED.
C       ADDITIONAL d FUNCTIONS ARE FOR Na AND HEAVIER ATOMS ONLY. 
C       f FUNCTIONS LEAD TO FAILURE IN GAUSSIAN.
        BAS='STO-nG'
        IF(BASNAM(6:6).EQ.'*') ND=1
        MAXATNO=11
        K=6
        RETURN
      ENDIF
      IF(BASNAM(2:4).EQ.'-21') THEN
C       MUST ACCOMMODATE 3-21G AND 3-21G*.
C       GAUSSIAN HAS 3-21G OR 6-21G. BOTH CAN USE THIS VBOLIB.
C       d ORBITALS ARE ALLOWED ONLY FOR Na ON, BUT f ORBITALS 
C       ARE NOT ALLOWED AS WITH STO. POLARISATION p IS OK FOR H.
        BAS='3-21G'
        IF(BASNAM(6:6).EQ.'*') ND=1
        IF(BASNAM(7:7).EQ.'*') NP=1
        MAXATNO=11
        K=5
        RETURN
      ENDIF
      IF(BASNAM(2:4).EQ.'-31') THEN
C     MUST ACCOMMODATE 6-31G*,6-31G**,6-31+G*,6-31++G** AND OTHERS.
C     GAUSSIAN HAS 4-31G AND 6-31G. BOTH CAN USE THIS VBOLIB.
C     MAYBE FIT D95V IN HERE ??
        BAS='6-31G'
        IF(BASNAM(5:5).EQ.'+') DSP=.TRUE.
        IF(BASNAM(6:6).EQ.'+') DS=.TRUE.
        DO I=1,20
        IF(BASNAM(I:I).EQ.'(') THEN
          LB=I+1
          GOTO 11
        ENDIF  
        ENDDO
 11     IF(BASNAM(LB:LB).EQ.'d') THEN
          ND=1
          I=LB+1
        ENDIF       
        IF(BASNAM(LB+1:LB+1).EQ.'d') THEN
          READ(BASNAM(LB:LB),'(I1)') J
          ND=J
          I=LB+2
        ENDIF       
        IF(BASNAM(I:I).EQ.'f') THEN
          NF=1
          LB=I
        ENDIF       
        IF(BASNAM(I+1:I+1).EQ.'f') THEN
          READ(BASNAM(I:I),'(I1)') J
          NF=J
          LB=I+1
        ENDIF
        I=LB       
        IF(BASNAM(I:I).EQ.'g') THEN
          NG=1
        ENDIF       
        IF(BASNAM(I+1:I+1).EQ.'f') THEN
          READ(BASNAM(I:I),'(I1)') J
          NG=J
        ENDIF
        K=5
        RETURN
      ENDIF
      IF(BASNAM(2:5).EQ.'-311') THEN
C     MUST ACCOMMODATE 6-311G*,6-311G**,6-311+G*,6-311++G** AND OTHERS.
C     GAUSSIAN HAS 6-311G ONLY. BOTH CAN USE THIS VBOLIB.
        BAS='6-311G'
        IF(BASNAM(6:6).EQ.'+') DSP=.TRUE.
        IF(BASNAM(7:7).EQ.'+') DS=.TRUE.
        DO I=1,20
        IF(BASNAM(I:I).EQ.'(') THEN
          LB=I+1
          GOTO 12
        ENDIF  
        ENDDO
 12     IF(BASNAM(LB:LB).EQ.'d') THEN
          ND=1
          I=LB+1
        ENDIF       
        IF(BASNAM(LB+1:LB+1).EQ.'d') THEN
          READ(BASNAM(LB:LB),'(I1)') J
          ND=J
          I=LB+2
        ENDIF       
        IF(BASNAM(I:I).EQ.'f') THEN
          NF=1
        ENDIF       
        IF(BASNAM(I+1:I+1).EQ.'f') THEN
          READ(BASNAM(I:I),'(I1)') J
          ND=J
        ENDIF       
        K=5
        RETURN
      ENDIF
      IF(BASNAM(1:5).EQ.'CC-pV') THEN
        IF (BASNAM(6:6).EQ.'D') BAS='CCPVDZ'
        IF (BASNAM(6:6).EQ.'T') BAS='CCPVTZ'
        IF (BASNAM(6:6).EQ.'Q') BAS='CCPVQZ'
        IF (BASNAM(6:6).NE.'D'.AND.BASNAM(6:6).NE.'T'.AND.
     &     BASNAM(6:6).NE.'Q') GOTO 13
        LCC = .TRUE.
        K=6
        RETURN
      ENDIF
      IF(BASNAM(1:9).EQ.'Aug-CC-pV') THEN
        IF (BASNAM(10:10).EQ.'D') BAS='AUG-CC-PVDZ'
        IF (BASNAM(10:10).EQ.'T') BAS='AUG-CC-PVTZ'
        IF (BASNAM(10:10).EQ.'Q') BAS='AUG-CC-PVQZ'
        IF (BASNAM(6:6).NE.'D'.AND.BASNAM(6:6).NE.'T'.AND.
     &     BASNAM(6:6).NE.'Q') GOTO 13
        LCC = .TRUE.
        K=11
        RETURN
      ENDIF
 13   WRITE(IOUT,101) BASNAM
      WRITE(IOUT,102)
      IOLVBO = 0
      RETURN
 101  FORMAT(/,' VBO LIB NOT AVAILABLE FOR BASIS = ',A16)
 102  FORMAT(' ALL FUNCTIONALITY RELATED TO LIB VBO WILL BE DISABLED')
      END
      SUBROUTINE MODVBOLIB(IOLVBO,IOT,FILENAME,IOK)
C     =================================================================
C
C     Modifies the VBOLIB to make it handle spherical harmonics, or
C     different ordering of f or g orbitals in Gaussian cartesians.
C
C     Brian Duke - August 2013
C
C     =================================================================
      IMPLICIT NONE
      INTEGER IOLVBO,IOT,IOK
      CHARACTER*80 FILENAME
C
      INTEGER NAT(10),NEW(10),I,J,K,L,L1,NT,NOLD,NEWTOT
      CHARACTER*2 DOLLAR
      CHARACTER*4 SYM,XSYM,YSYM,ZSYM
      CHARACTER*4 DSYM(5),FSYM1(7),FSYM2(10),GSYM1(9),GSYM2(15)
      CHARACTER*50 BUFF,BUFFER(120)
      DOUBLE PRECISION ZERO
C
      INTEGER NUMD,NUMF
      COMMON /DORF/ NUMD,NUMF
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      CHARACTER*16 BASNAM
      INTEGER LENBAS,ND,NF,NG,NP
      LOGICAL DS,DSP,LCC
      COMMON /BASIS/LENBAS,ND,NF,NG,NP,DS,DSP,LCC,BASNAM
C
      DATA DSYM/' D 0',' D+1',' D-1',' D+2',' D-2'/
      DATA FSYM1/' F 0',' F+1',' F-1',' F+2',' F-2',' F+3',' F-3'/
      DATA FSYM2/' xxx',' yyy',' zzz',' xyy',' xxy',' xxz',' xzz'
     & ,' yzz',' yyz',' xyz'/
      DATA GSYM1/' G 0',' G+1',' G-1',' G+2',' G-2',' G+3',' G-3'
     & ,' G+4',' G-4'/
      DATA GSYM2/'zzzz','yzzz','yyzz','yyyz','yyyy','xzzz','xyzz'
     & ,'xyyz','xyyy','xxzz','xxyz','xxyy','xxxz','xxxy','xxxx'/
      DATA XSYM/'  xx'/
      DATA YSYM/' xxx'/
      DATA ZSYM/'xxxx'/
      DATA DOLLAR/'$'/
      DATA ZERO/0.0D0/
C
      IF(((NUMD.EQ.1.AND.NUMF.EQ.1).OR.
     & (ND.EQ.0.AND.NF.EQ.0.AND.NG.EQ.0)).AND..NOT.LCC) RETURN
C     NOTHING TO DO
C
      WRITE(IOUT,100)
      OPEN(UNIT=IOT,FILE=FILENAME,STATUS="UNKNOWN",ERR=3)
 1    READ(IOLVBO,101,END=2) BUFF
      DO I=1,20
        IF(BUFF(I:I).EQ.DOLLAR) GOTO 4
      ENDDO
      WRITE(IOT,101) BUFF
      GOTO 1
 4    WRITE(IOT,101) BUFF
      READ(IOLVBO,101,END=2) BUFF
      READ(BUFF,*) NT
      WRITE(IOT,101) BUFF
      NT=NT+1
      DO I=1,NT
        READ(IOLVBO,101,END=2) BUFF
        WRITE(IOT,101) BUFF
      ENDDO
      READ(IOLVBO,101,END=2) BUFF
      READ(BUFF(1:3),'(I3)') NT
C     NT IS NUMBER OF ATOMS INVOLVED, USUALLY JUST 1
      WRITE(IOT,101) BUFF
      READ(IOLVBO,101,END=2) BUFF
      WRITE(IOT,101) BUFF
      READ(IOLVBO,101,END=2) BUFF
      READ(BUFF,*) (NAT(I),I=1,NT)
      K=1
      I=1
      NOLD=0
      DO L=1,NT
        NOLD=NOLD+NAT(L)
        DO L1=K,NOLD
          READ(IOLVBO,101,END=2) BUFFER(L1)
        ENDDO
 10     READ(BUFFER(K),101,END=2) BUFF
        READ(BUFF(13:16),'(A4)') SYM
        IF(SYM.EQ.XSYM.AND.NUMD.EQ.0) THEN
          WRITE(BUFF(1:4),'(I4)') I
          WRITE(BUFF(13:16),'(A4)') DSYM(1)
          WRITE(BUFF(17:26),'(F10.5)') ZERO
          WRITE(BUFFER(I),101) BUFF
          DO J=1,4
            READ(BUFFER(K+J),101,END=2) BUFF
            WRITE(BUFF(1:4),'(I4)') I+J
            WRITE(BUFF(13:16),'(A4)') DSYM(J+1)
            WRITE(BUFF(17:26),'(F10.5)') ZERO
            WRITE(BUFFER(I+J),101) BUFF
          ENDDO
          K=K+6
          I=I+5
        ELSE IF(SYM.EQ.YSYM.AND.NUMF.EQ.0) THEN
          WRITE(BUFF(1:4),'(I4)') I
          WRITE(BUFF(13:16),'(A4)') FSYM1(1)
          WRITE(BUFF(17:26),'(F10.5)') ZERO
          WRITE(BUFFER(I),101) BUFF
          DO J=1,6
            READ(BUFFER(K+J),101,END=2) BUFF
            WRITE(BUFF(1:4),'(I4)') I+J
            WRITE(BUFF(13:16),'(A4)') FSYM1(J+1)
            WRITE(BUFF(17:26),'(F10.5)') ZERO
            WRITE(BUFFER(I+J),101) BUFF
          ENDDO
          K=K+10
          I=I+7
        ELSE IF(SYM.EQ.YSYM.AND.NUMF.EQ.1) THEN
          WRITE(BUFF(1:4),'(I4)') I
          WRITE(BUFF(13:16),'(A4)') FSYM2(1)
          WRITE(BUFF(17:26),'(F10.5)') ZERO
          WRITE(BUFFER(I),101) BUFF
          DO J=1,9
            READ(BUFFER(K+J),101,END=2) BUFF
            WRITE(BUFF(1:4),'(I4)') I+J
            WRITE(BUFF(13:16),'(A4)') FSYM2(J+1)
            WRITE(BUFF(17:26),'(F10.5)') ZERO
            WRITE(BUFFER(I+J),101) BUFF
          ENDDO
          K=K+10
          I=I+10
        ELSE IF(SYM.EQ.ZSYM.AND.NUMF.EQ.0) THEN
          WRITE(BUFF(1:4),'(I4)') I
          WRITE(BUFF(13:16),'(A4)') GSYM1(1)
          WRITE(BUFF(17:26),'(F10.5)') ZERO
          WRITE(BUFFER(I),101) BUFF
          DO J=1,8
            READ(BUFFER(K+J),101,END=2) BUFF
            WRITE(BUFF(1:4),'(I4)') I+J
            WRITE(BUFF(13:16),'(A4)') GSYM1(J+1)
            WRITE(BUFF(17:26),'(F10.5)') ZERO
            WRITE(BUFFER(I+J),101) BUFF
          ENDDO
          K=K+15
          I=I+9
        ELSE IF(SYM.EQ.ZSYM.AND.NUMF.EQ.1) THEN
          WRITE(BUFF(1:4),'(I4)') I
          WRITE(BUFF(13:16),'(A4)') GSYM2(1)
          WRITE(BUFF(17:26),'(F10.5)') ZERO
          WRITE(BUFFER(I),101) BUFF
          DO J=1,14
            READ(BUFFER(K+J),101,END=2) BUFF
            WRITE(BUFF(1:4),'(I4)') I+J
            WRITE(BUFF(13:16),'(A4)') GSYM2(J+1)
            WRITE(BUFF(17:26),'(F10.5)') ZERO
            WRITE(BUFFER(I+J),101) BUFF
          ENDDO
          K=K+15
          I=I+15
        ELSE
          WRITE(BUFF(1:4),'(I4)') I
          WRITE(BUFFER(I),101) BUFF
          I=I+1
          K=K+1
        ENDIF
        IF(K.LE.NOLD) GOTO 10
        IF (L.EQ.1) THEN
          NEW(L)=I-1
        ELSE
          NEW(L)=I-1-NEW(L-1)
        ENDIF
      ENDDO
      WRITE(IOT,'(10I3)') (NEW(L1),L1=1,NT)
      NEWTOT=0
      DO L1=1,NT
        NEWTOT=NEWTOT+NEW(L1)
      ENDDO
      DO I=1,NEWTOT
        WRITE(IOT,101) BUFFER(I)
      ENDDO
      GOTO 1
 2    CLOSE(IOT)
      CLOSE(IOLVBO)
      OPEN(UNIT=IOLVBO, FILE=FILENAME, STATUS="OLD",ERR=3)
      REWIND(IOLVBO)
      IF(IOK.EQ.1) THEN
        WRITE(IOUT,'(/," LISTING VBOLIB ",80A,/)') FILENAME
 11     READ(IOLVBO,101,END=22) BUFF
        WRITE(IOUT,101) BUFF
        GOTO 11
      ENDIF
 22   REWIND(IOLVBO)
 3    CONTINUE
      RETURN
 100  FORMAT(' MODIFYING VBOLIB FOR GAUSSIAN IN MODVBOLIB')
 101  FORMAT(A50)
      END
      SUBROUTINE ADDVBOLIB(IOLVBO,IOT,FILENAME,MAXATNO,IOK)
C     =================================================================
C
C     Modifies the VBOLIB of a simple basis set, such as 6-31G,  to add
C     polarisation and diffuse functions. Note that these are all in
C     cartesian form and in GAMESS order for f and g. Both these
C     features may be changed later in SUBROUTINE MODVBOLIB.
C
C     For GAUSSIAN/VB2000 only.
C
C     Brian Duke - August 2013
C
C     =================================================================
      IMPLICIT NONE
      INTEGER IOLVBO,IOT,IOK,MAXATNO
      CHARACTER*80 FILENAME
C
      INTEGER NAT(10),NEW(10)
      INTEGER I,K,L,L1,NT,NOLD,NEWTOT,NATNO
      CHARACTER*2 DOLLAR
      CHARACTER*4 SYM,SSYM,DSYM(6),PSYM(3),SPSYM(4)
      CHARACTER*3 FSYM(10)
      CHARACTER*4 GSYM(15)
      CHARACTER*50 BUFF,BUFFER(120),BUFFER2(120)
      DOUBLE PRECISION ZERO
C
      INTEGER IN,IOUT,IPUNCH,IU,ICHK
      COMMON /IO/ IN,IOUT,IPUNCH,IU,ICHK
C
      CHARACTER*16 BASNAM
      INTEGER LENBAS,ND,NF,NG,NP
      LOGICAL DS,DSP,LCC
      COMMON /BASIS/LENBAS,ND,NF,NG,NP,DS,DSP,LCC,BASNAM
C     BASNAM IS BASIS SET NAME FROM FORMATTED CHECKPOINT FILE, WHILE
C     BASNAME IS FROM #1 LINE IN STAND-ALONE VERSION.
C
      DATA DSYM/'xx','yy','zz','xy','xz','yz'/
      DATA PSYM/' x',' y',' z'/
      DATA SPSYM/' s',' x',' y',' z'/
      DATA FSYM/'xxx','yyy','zzz','xxy','xxz','yyx','yyz'
     & ,'zzx','zzy','xyz'/
      DATA GSYM/'xxxx','yyyy','zzzz','xxxy','xxxz','yyyx','yyyz',
     & 'zzzx','zzzy','xxyy','xxzz','yyzz','xxyz','yyxz','zzxy'/
      DATA SSYM/' s'/
      DATA DOLLAR/'$'/
      DATA ZERO/0.0D0/
C
      IF(ND.EQ.0.AND.NF.EQ.0.AND.NG.EQ.0.AND.NP.EQ.0.AND..NOT.DSP
     & .AND..NOT.DS) RETURN
C     NOTHING TO DO
C
 21   FORMAT(/," BASIS IN BASNAM IS ",A16)
 22   FORMAT(" ND =",I2," NF =",I2," NG =",I2," NP =",I2,
     & " DSP =",L2," DS =",L2)
      WRITE(IOUT,100)
      WRITE(IOUT,21) BASNAM
      WRITE(IOUT,22) ND,NF,NG,NP,DSP,DS
      OPEN(UNIT=IOT, FILE=FILENAME, STATUS="UNKNOWN",ERR=3)
 1    READ(IOLVBO,101,END=2) BUFF
      DO I=1,20
        IF(BUFF(I:I).EQ.DOLLAR) GOTO 4
      ENDDO
      WRITE(IOT,101) BUFF
      GOTO 1
 4    WRITE(IOT,101) BUFF
      READ(IOLVBO,101,END=2) BUFF
      READ(BUFF,*) NT
      WRITE(IOT,101) BUFF
      NT=NT+1
      DO I=1,NT
        READ(IOLVBO,101,END=2) BUFF
        IF(I.EQ.1) READ(BUFF(1:3),'(I3)') NATNO
        WRITE(IOT,101) BUFF
      ENDDO
      READ(IOLVBO,101,END=2) BUFF
      READ(BUFF(1:3),'(I3)') NT
C     NT IS NUMBER OF ATOMS INVOLVED, USUALLY JUST 1
      WRITE(IOT,101) BUFF
      READ(IOLVBO,101,END=2) BUFF
      WRITE(IOT,101) BUFF
      READ(IOLVBO,101,END=2) BUFF
      READ(BUFF,*) (NAT(I),I=1,NT)
      K=1
      NOLD=0
      DO L=1,NT
        I=(L-1)*NAT(L) + 1
        NOLD=NOLD+NAT(L)
        DO L1=I,NOLD
          READ(IOLVBO,101,END=2) BUFF
          WRITE(BUFF(1:4),'(I4)') K
          WRITE(BUFFER(L1),101) BUFF
          WRITE(BUFFER2(K),101) BUFFER(L1)
          K=K+1
        ENDDO
        READ(BUFFER(1),'(A50)') BUFF
        READ(BUFF(9:10),'(A2)') SYM
        IF(DSP.AND.SYM.NE.' H') THEN
          DO I=1,4
            WRITE(BUFF(1:4),'(I4)') K
            WRITE(BUFF(5:7),'(I3)') L
            WRITE(BUFF(9:10),'(A2)') SYM
            WRITE(BUFF(15:16),'(A2)') SPSYM(I)
            WRITE(BUFF(17:26),'(F10.5)') ZERO
            WRITE(BUFFER2(K),101) BUFF
            K=K+1
          ENDDO
        ENDIF
        IF(DS.AND.SYM.EQ.' H') THEN
          WRITE(BUFF(1:4),'(I4)') K
          WRITE(BUFF(5:7),'(I3)') L
          WRITE(BUFF(9:10),'(A2)') SYM
          WRITE(BUFF(15:16),'(A2)') SSYM
          WRITE(BUFF(17:26),'(F10.5)') ZERO
          WRITE(BUFFER2(K),101) BUFF
          K=K+1
        ENDIF
        IF(ND.GT.0.AND.SYM.NE.' H'.AND.NATNO.GE.MAXATNO) THEN
C         FOR 3-21G and STO-nG, d ADDED ONLY FOR Na ON
          DO L1=1,ND
            DO I=1,6
              WRITE(BUFF(1:4),'(I4)') K
              WRITE(BUFF(5:7),'(I3)') L
              WRITE(BUFF(9:10),'(A2)') SYM
              WRITE(BUFF(15:16),'(A2)') DSYM(I)
              WRITE(BUFF(17:26),'(F10.5)') ZERO
              WRITE(BUFFER2(K),101) BUFF
              K=K+1
            ENDDO
          ENDDO
        ENDIF
        IF(NF.GT.0.AND.SYM.NE.' H') THEN
          DO L1=1,NF
            DO I=1,10
              WRITE(BUFF(1:4),'(I4)') K
              WRITE(BUFF(5:7),'(I3)') L
              WRITE(BUFF(9:10),'(A2)') SYM
              WRITE(BUFF(14:16),'(A3)') FSYM(I)
              WRITE(BUFF(17:26),'(F10.5)') ZERO
              WRITE(BUFFER2(K),101) BUFF
              K=K+1
            ENDDO
          ENDDO
        ENDIF
        IF(NG.GT.0.AND.SYM.NE.' H') THEN
          DO L1=1,NG
            DO I=1,15
              WRITE(BUFF(1:4),'(I4)') K
              WRITE(BUFF(5:7),'(I3)') L
              WRITE(BUFF(9:10),'(A2)') SYM
              WRITE(BUFF(13:16),'(A4)') GSYM(I)
              WRITE(BUFF(17:26),'(F10.5)') ZERO
              WRITE(BUFFER2(K),101) BUFF
              K=K+1
            ENDDO
          ENDDO
        ENDIF
        IF(NP.GT.0.AND.SYM.EQ.' H') THEN
          DO L1=1,NP
            DO I=1,3
              WRITE(BUFF(1:4),'(I4)') K
              WRITE(BUFF(5:7),'(I3)') L
              WRITE(BUFF(9:10),'(A2)') SYM
              WRITE(BUFF(15:16),'(A2)') PSYM(I)
              WRITE(BUFF(17:26),'(F10.5)') ZERO
              WRITE(BUFFER2(K),101) BUFF
              K=K+1
            ENDDO
          ENDDO
        ENDIF
        IF (L.EQ.1) THEN
          NEW(L)=K-1
        ELSE
          NEW(L)=K-1-NEW(L-1)
        ENDIF
      ENDDO
      WRITE(IOT,'(10I3)') (NEW(L1),L1=1,NT)
      NEWTOT=0
      DO L1=1,NT
        NEWTOT=NEWTOT+NEW(L1)
      ENDDO
      DO I=1,NEWTOT
        WRITE(IOT,101) BUFFER2(I)
      ENDDO
      GOTO 1
 2    CLOSE(IOT)
      CLOSE(IOLVBO)
      OPEN(UNIT=IOLVBO, FILE=FILENAME, STATUS="OLD",ERR=3)
      REWIND(IOLVBO)
      IF(IOK.EQ.1) THEN
        WRITE(IOUT,'(/," LISTING VBOLIB ",80A,/)') FILENAME
 11     READ(IOLVBO,101,END=12) BUFF
        WRITE(IOUT,101) BUFF
        GOTO 11
      ENDIF
 12   REWIND(IOLVBO)
 3    CONTINUE
      RETURN
 100  FORMAT(' MODIFYING VBOLIB FOR GAUSSIAN IN ADDVBOLIB')
 101  FORMAT(A50)
      END
C
C*BLAS MODULES
C
C     These 9 routines that follow are the only routines from
C     vb2blas.src that are needed in Gaussian VB2000.
C
C*MODULE EIGEN   *DECK GIVEIS
      SUBROUTINE GIVEIS(N,NVECT,NV,A,B,INDB,ROOT,VECT,IERR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(*),B(N,8),INDB(N),ROOT(N),VECT(NV,NVECT)
C
C     EISPACK-BASED SUBSTITUTE FOR QCPE ROUTINE GIVENS.
C     FINDS ALL EIGENVALUES AND SOME EIGENVECTORS OF A REAL SYMMETRIC
C     MATRIX.   AUTHOR.. C. MOLER AND D. SPANGLER, N.R.C.C., 4/1/79.
C
C     INPUT..
C     N     = ORDER OF MATRIX .
C     NVECT = NUMBER OF VECTORS DESIRED.  0 .LE. NVECT .LE. N .
C     NV    = LEADING DIMENSION OF VECT .
C     A     = INPUT MATRIX, COLUMNS OF THE UPPER TRIANGLE PACKED INTO
C             LINEAR ARRAY OF DIMENSION N*(N+1)/2 .
C     B     = SCRATCH ARRAY, 8*N ELEMENTS (NOTE THIS IS MORE THAN
C             PREVIOUS VERSIONS OF GIVENS.)
C    IND    = INDEX ARRAY OF N ELEMENTS
C
C     OUTPUT..
C     A       DESTROYED .
C     ROOT  = ALL EIGENVALUES, ROOT(1) .LE. ... .LE. ROOT(N) .
C             (FOR OTHER ORDERINGS, SEE BELOW.)
C     VECT  = EIGENVECTORS FOR ROOT(1),..., ROOT(NVECT) .
C     IERR  = 0 IF NO ERROR DETECTED,
C           = K IF ITERATION FOR K-TH EIGENVALUE FAILED,
C           = -K IF ITERATION FOR K-TH EIGENVECTOR FAILED.
C             (FAILURES SHOULD BE VERY RARE.  CONTACT MOLER.)
C
C     CALLS MODIFIED EISPACK ROUTINES TRED3B, IMTQLV, TINVTB, AND
C     TRBK3B.  THE ROUTINES TRED3B, TINVTB, AND TRBK3B.
C     THE ORIGINAL EISPACK ROUTINES TRED3, TINVIT, AND TRBAK3
C     WERE MODIFIED BY THE INTRODUCTION OF TWO ROUTINES FROM THE
C     BLAS LIBRARY - DDOT AND DAXPY.
C
C         IF TINVIT FAILS TO CONVERGE, TQL2 IS CALLED
C
C         SEE EISPACK USERS GUIDE, B. T. SMITH ET AL, SPRINGER-VERLAG
C     LECTURE NOTES IN COMPUTER SCIENCE, VOL. 6, 2-ND EDITION, 1976 .
C     NOTE THAT IMTQLV AND TINVTB HAVE INTERNAL MACHINE
C     DEPENDENT CONSTANTS.
C
      DATA ONE, ZERO /1.0D+00, 0.0D+00/
      CALL TRED3B(N,(N*N+N)/2,A,B(1,1),B(1,2),B(1,3))
      CALL IMTQLV(N,B(1,1),B(1,2),B(1,3),ROOT,INDB,IERR,B(1,4))
      IF (IERR .NE. 0) RETURN
C
C     TO REORDER ROOTS...
C     K = N/2
C     B(1,3) = 2.0D+00
C     DO 50 I = 1, K
C        J = N+1-I
C        T = ROOT(I)
C        ROOT(I) = ROOT(J)
C        ROOT(J) = T
C 50  CONTINUE
C
      IF (NVECT .LE. 0) RETURN
      CALL TINVTB(NV,N,B(1,1),B(1,2),B(1,3),NVECT,ROOT,INDB,VECT,IERR,
     +     B(1,4),B(1,5),B(1,6),B(1,7),B(1,8))
      IF (IERR .EQ. 0) GO TO 160
C
C      IF INVERSE ITERATION GIVES AN ERROR IN DETERMINING THE
C      EIGENVECTORS, TRY THE QL ALGORITHM IF ALL THE EIGENVECTORS
C      ARE DESIRED.
C
      IF (NVECT .NE. N) RETURN
      DO 120 I = 1, NVECT
      DO 100 J = 1, N
      VECT(I,J) = ZERO
  100 CONTINUE
      VECT(I,I) = ONE
  120 CONTINUE
      CALL TQL2 (NV,N,B(1,1),B(1,2),VECT,IERR)
      DO 140 I = 1, NVECT
      ROOT(I) = B(I,1)
  140 CONTINUE
      IF (IERR .NE. 0) RETURN
  160 CALL TRBK3B(NV,N,(N*N+N)/2,A,NVECT,VECT)
      RETURN
      END
C*MODULE EIGEN   *DECK TRED3B
C
C     ------------------------------------------------------------------
C
      SUBROUTINE TRED3B(N,NV,A,D,E,E2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(NV),D(N),E(N),E2(N)
C
C     THIS ROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TRED3,
C     NUM. MATH. 11, 181-195(1968) BY MARTIN, REINSCH, AND WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
C
C     THIS ROUTINE REDUCES A REAL SYMMETRIC MATRIX, STORED AS
C     A ONE-DIMENSIONAL ARRAY, TO A SYMMETRIC TRIDIAGONAL MATRIX
C     USING ORTHOGONAL SIMILARITY TRANSFORMATIONS.
C
C     ON INPUT-
C
C        N IS THE ORDER OF THE MATRIX,
C
C        NV MUST BE SET TO THE DIMENSION OF THE ARRAY PARAMETER A
C          AS DECLARED IN THE CALLING ROUTINE DIMENSION STATEMENT,
C
C        A CONTAINS THE LOWER TRIANGLE OF THE REAL SYMMETRIC
C          INPUT MATRIX, STORED ROW-WISE AS A ONE-DIMENSIONAL
C          ARRAY, IN ITS FIRST N*(N+1)/2 POSITIONS.
C
C     ON OUTPUT-
C
C        A CONTAINS INFORMATION ABOUT THE ORTHOGONAL
C          TRANSFORMATIONS USED IN THE REDUCTION,
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE TRIDIAGONAL MATRIX,
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
C          MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS SET TO ZERO,
C
C        E2 CONTAINS THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
C          E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
C     ********** FOR I=N STEP -1 UNTIL 1 DO -- **********
      DO 300 II = 1, N
      I = N + 1 - II
      L = I - 1
      IZ = (I * L) / 2
      H = 0.0D+00
      SCALE = 0.0D+00
      IF (L .LT. 1) GO TO 120
C     ********** SCALE ROW (ALGOL TOL THEN NOT NEEDED) **********
      DO 100 K = 1, L
      IZ = IZ + 1
      D(K) = A(IZ)
      SCALE = SCALE + ABS(D(K))
  100 CONTINUE
C
      IF (SCALE .NE. 0.0D+00) GO TO 140
  120 E(I) = 0.0D+00
      E2(I) = 0.0D+00
      GO TO 280
C
  140 DO 160 K = 1, L
      D(K) = D(K) / SCALE
      H = H + D(K) * D(K)
  160 CONTINUE
C
      E2(I) = SCALE * SCALE * H
      F = D(L)
      G = -SIGN(SQRT(H),F)
      E(I) = SCALE * G
      H = H - F * G
      D(L) = F - G
      A(IZ) = SCALE * D(L)
      IF (L .EQ. 1) GO TO 280
      F = 0.0D+00
C
      JK = 1
      DO 220 J = 1, L
      JM1 = J - 1
      DT = D(J)
      G = 0.0D+00
C     ********** FORM ELEMENT OF A*U **********
      IF (JM1 .EQ. 0) GO TO 200
      DO 180 K = 1, JM1
      E(K) = E(K) + DT * A(JK)
      G = G + D(K) * A(JK)
      JK = JK + 1
  180 CONTINUE
  200 E(J) = G + A(JK) * DT
      JK = JK + 1
C     ********** FORM ELEMENT OF P **********
  220 CONTINUE
      F = 0.0D+00
      DO 240 J = 1, L
      E(J) = E(J) / H
      F = F + E(J) * D(J)
  240 CONTINUE
C
      HH = F / (H + H)
      JK = 0
C     ********** FORM REDUCED A **********
      DO 260 J = 1, L
      F = D(J)
      G = E(J) - HH * F
      E(J) = G
C
      DO 260 K = 1, J
      JK = JK + 1
      A(JK) = A(JK) - F * E(K) - G * D(K)
  260 CONTINUE
C
  280 D(I) = A(IZ+1)
      A(IZ+1) = SCALE * SQRT(H)
  300 CONTINUE
C
      RETURN
C     ********** LAST CARD OF TRED3 **********
      END
C*MODULE EIGEN   *DECK TRBK3B
C
C     ------------------------------------------------------------------
C
      SUBROUTINE TRBK3B(NM,N,NV,A,M,Z)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(NV),Z(NM,M)
C
C     THIS ROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TRBAK3,
C     NUM. MATH. 11, 181-195(1968) BY MARTIN, REINSCH, AND WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
C
C     THIS ROUTINE FORMS THE EIGENVECTORS OF A REAL SYMMETRIC
C     MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
C     SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY  TRED3B.
C
C     ON INPUT-
C
C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
C          ARRAY PARAMETERS AS DECLARED IN THE CALLING ROUTINE
C          DIMENSION STATEMENT,
C
C        N IS THE ORDER OF THE MATRIX,
C
C        NV MUST BE SET TO THE DIMENSION OF THE ARRAY PARAMETER A
C          AS DECLARED IN THE CALLING ROUTINE DIMENSION STATEMENT,
C
C        A CONTAINS INFORMATION ABOUT THE ORTHOGONAL TRANSFORMATIONS
C          USED IN THE REDUCTION BY  TRED3B IN ITS FIRST
C          N*(N+1)/2 POSITIONS,
C
C        M IS THE NUMBER OF EIGENVECTORS TO BE BACK TRANSFORMED,
C
C        Z CONTAINS THE EIGENVECTORS TO BE BACK TRANSFORMED
C          IN ITS FIRST M COLUMNS.
C
C     ON OUTPUT-
C
C        Z CONTAINS THE TRANSFORMED EIGENVECTORS
C          IN ITS FIRST M COLUMNS.
C
C     NOTE THAT TRBAK3 PRESERVES VECTOR EUCLIDEAN NORMS.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
      IF (M .EQ. 0) GO TO 140
      IF (N .EQ. 1) GO TO 140
C
      DO 120 I = 2, N
      L = I - 1
      IZ = (I * L) / 2
      IK = IZ + I
      H = A(IK)
      IF (H .EQ. 0.0D+00) GO TO 120
C
      DO 100 J = 1, M
      S = -DDOT(L,A(IZ+1),1,Z(1,J),1)
C
C     ********** DOUBLE DIVISION AVOIDS POSSIBLE UNDERFLOW **********
      S = (S / H) / H
C
      CALL DAXPY(L,S,A(IZ+1),1,Z(1,J),1)
C
  100 CONTINUE
C
  120 CONTINUE
C
  140 RETURN
C     ********** LAST CARD OF TRBAK3 **********
      END
C*MODULE EIGEN   *DECK TQL2
C
C     ------------------------------------------------------------------
C
      SUBROUTINE TQL2(NM,N,D,E,Z,IERR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION MACHEP
      DIMENSION D(N),E(N),Z(NM,N)
C
C     THIS ROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TQL2,
C     NUM. MATH. 11, 293-306(1968) BY BOWDLER, MARTIN, REINSCH, AND
C     WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 227-240(1971).
C
C     THIS ROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
C     OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE QL METHOD.
C     THE EIGENVECTORS OF A FULL SYMMETRIC MATRIX CAN ALSO
C     BE FOUND IF  TRED2  HAS BEEN USED TO REDUCE THIS
C     FULL MATRIX TO TRIDIAGONAL FORM.
C
C     ON INPUT-
C
C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
C          ARRAY PARAMETERS AS DECLARED IN THE CALLING ROUTINE
C          DIMENSION STATEMENT,
C
C        N IS THE ORDER OF THE MATRIX,
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX,
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
C          IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY,
C
C        Z CONTAINS THE TRANSFORMATION MATRIX PRODUCED IN THE
C          REDUCTION BY  TRED2, IF PERFORMED.  IF THE EIGENVECTORS
C          OF THE TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN
C          THE IDENTITY MATRIX.
C
C      ON OUTPUT-
C
C        D CONTAINS THE EIGENVALUES IN ASCENDING ORDER.  IF AN
C          ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT
C          UNORDERED FOR INDICES 1,2,...,IERR-1,
C
C        E HAS BEEN DESTROYED,
C
C        Z CONTAINS ORTHONORMAL EIGENVECTORS OF THE SYMMETRIC
C          TRIDIAGONAL (OR FULL) MATRIX.  IF AN ERROR EXIT IS MADE,
C          Z CONTAINS THE EIGENVECTORS ASSOCIATED WITH THE STORED
C          EIGENVALUES,
C
C        IERR IS SET TO
C          ZERO       FOR NORMAL RETURN,
C          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
C                     DETERMINED AFTER 30 ITERATIONS.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
C     ********** MACHEP IS A MACHINE DEPENDENT PARAMETER SPECIFYING
C                THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.
C
C                **********
      MACHEP = 2.0D+00**(-50)
C
      IERR = 0
      IF (N .EQ. 1) GO TO 400
C
      DO 100 I = 2, N
  100 E(I-1) = E(I)
C
      F = 0.0D+00
      B = 0.0D+00
      E(N) = 0.0D+00
C
      DO 300 L = 1, N
      J = 0
      H = MACHEP * (ABS(D(L)) + ABS(E(L)))
      IF (B .LT. H) B = H
C     ********** LOOK FOR SMALL SUB-DIAGONAL ELEMENT **********
      DO 120 M = L, N
      IF (ABS(E(M)) .LE. B) GO TO 140
C     ********** E(N) IS ALWAYS ZERO, SO THERE IS NO EXIT
C                THROUGH THE BOTTOM OF THE LOOP **********
  120 CONTINUE
C
  140 IF (M .EQ. L) GO TO 280
  160 IF (J .EQ. 30) GO TO 380
      J = J + 1
C     ********** FORM SHIFT **********
      L1 = L + 1
      G = D(L)
      P = (D(L1) - G) / (2.0D+00 * E(L))
      R = SQRT(P*P+1.0D+00)
      D(L) = E(L) / (P + SIGN(R,P))
      H = G - D(L)
C
      DO 180 I = L1, N
  180 D(I) = D(I) - H
C
      F = F + H
C     ********** QL TRANSFORMATION **********
      P = D(M)
      C = 1.0D+00
      S = 0.0D+00
      MML = M - L
C     ********** FOR I=M-1 STEP -1 UNTIL L DO -- **********
      DO 260 II = 1, MML
      I = M - II
      G = C * E(I)
      H = C * P
      IF (ABS(P) .LT. ABS(E(I))) GO TO 200
      C = E(I) / P
      R = SQRT(C*C+1.0D+00)
      E(I+1) = S * P * R
      S = C / R
      C = 1.0D+00 / R
      GO TO 220
  200 C = P / E(I)
      R = SQRT(C*C+1.0D+00)
      E(I+1) = S * E(I) * R
      S = 1.0D+00 / R
      C = C * S
  220 P = C * D(I) - S * G
      D(I+1) = H + S * (C * G + S * D(I))
C     ********** FORM VECTOR **********
      CALL DROT(N,Z(1,I+1),1,Z(1,I),1,C,S)
C
  260 CONTINUE
C
      E(L) = S * P
      D(L) = C * P
      IF (ABS(E(L)) .GT. B) GO TO 160
  280 D(L) = D(L) + F
  300 CONTINUE
C     ********** ORDER EIGENVALUES AND EIGENVECTORS **********
      DO 360 II = 2, N
      I = II - 1
      K = I
      P = D(I)
C
      DO 320 J = II, N
      IF (D(J) .GE. P) GO TO 320
      K = J
      P = D(J)
  320 CONTINUE
C
      IF (K .EQ. I) GO TO 360
      D(K) = D(I)
      D(I) = P
C
      CALL DSWAP(N,Z(1,I),1,Z(1,K),1)
C
  360 CONTINUE
C
      GO TO 400
C     ********** SET ERROR -- NO CONVERGENCE TO AN
C                EIGENVALUE AFTER 30 ITERATIONS **********
  380 IERR = L
  400 RETURN
C     ********** LAST CARD OF TQL2 **********
      END
C*MODULE EIGEN   *DECK TINVTB
      SUBROUTINE TINVTB(NM,N,D,E,E2,M,W,IND,Z,
     *                  IERR,RV1,RV2,RV3,RV4,RV6)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION D(N),E(N),E2(N),W(M),Z(NM,M),
     *          RV1(N),RV2(N),RV3(N),RV4(N),RV6(N),IND(M)
      DOUBLE PRECISION MACHEP,NORM
      INTEGER P,Q,R,S,TAG,GROUP
C     ------------------------------------------------------------------
C
C     THIS ROUTINE IS A TRANSLATION OF THE INVERSE ITERATION TECH-
C     NIQUE IN THE ALGOL PROCEDURE TRISTURM BY PETERS AND WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 418-439(1971).
C
C     THIS ROUTINE FINDS THOSE EIGENVECTORS OF A TRIDIAGONAL
C     SYMMETRIC MATRIX CORRESPONDING TO SPECIFIED EIGENVALUES,
C     USING INVERSE ITERATION.
C
C     ON INPUT-
C
C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
C          ARRAY PARAMETERS AS DECLARED IN THE CALLING ROUTINE
C          DIMENSION STATEMENT,
C
C        N IS THE ORDER OF THE MATRIX,
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX,
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
C          IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY,
C
C        E2 CONTAINS THE SQUARES OF THE CORRESPONDING ELEMENTS OF E,
C          WITH ZEROS CORRESPONDING TO NEGLIGIBLE ELEMENTS OF E.
C          E(I) IS CONSIDERED NEGLIGIBLE IF IT IS NOT LARGER THAN
C          THE PRODUCT OF THE RELATIVE MACHINE PRECISION AND THE SUM
C          OF THE MAGNITUDES OF D(I) AND D(I-1).  E2(1) MUST CONTAIN
C          0.0 IF THE EIGENVALUES ARE IN ASCENDING ORDER, OR 2.0
C          IF THE EIGENVALUES ARE IN DESCENDING ORDER.  IF  BISECT,
C          TRIDIB, OR  IMTQLV  HAS BEEN USED TO FIND THE EIGENVALUES,
C          THEIR OUTPUT E2 ARRAY IS EXACTLY WHAT IS EXPECTED HERE,
C
C        M IS THE NUMBER OF SPECIFIED EIGENVALUES,
C
C        W CONTAINS THE M EIGENVALUES IN ASCENDING OR DESCENDING ORDER,
C
C        IND CONTAINS IN ITS FIRST M POSITIONS THE SUBMATRIX INDICES
C          ASSOCIATED WITH THE CORRESPONDING EIGENVALUES IN W --
C          1 FOR EIGENVALUES BELONGING TO THE FIRST SUBMATRIX FROM
C          THE TOP, 2 FOR THOSE BELONGING TO THE SECOND SUBMATRIX, ETC.
C
C     ON OUTPUT-
C
C        ALL INPUT ARRAYS ARE UNALTERED,
C
C        Z CONTAINS THE ASSOCIATED SET OF ORTHONORMAL EIGENVECTORS.
C          ANY VECTOR WHICH FAILS TO CONVERGE IS SET TO ZERO,
C
C        IERR IS SET TO
C          ZERO       FOR NORMAL RETURN,
C          -R         IF THE EIGENVECTOR CORRESPONDING TO THE R-TH
C                     EIGENVALUE FAILS TO CONVERGE IN 5 ITERATIONS,
C
C        RV1, RV2, RV3, RV4, AND RV6 ARE TEMPORARY STORAGE ARRAYS.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
C                **********
      MACHEP = 2.0D+00**(-50)
C
      IERR = 0
      IF (M .EQ. 0) GO TO 680
      TAG = 0
      ORDER = 1.0D+00 - E2(1)
      XU = 0.0D+00
      UK = 0.0D+00
      X0 = 0.0D+00
      U  = 0.0D+00
      EPS2 = 0.0D+00
      EPS3 = 0.0D+00
      EPS4 = 0.0D+00
      GROUP = 0
      Q = 0
C     ********** ESTABLISH AND PROCESS NEXT SUBMATRIX **********
  100 P = Q + 1
      IP = P + 1
C
      DO 120 Q = P, N
      IF (Q .EQ. N) GO TO 140
      IF (E2(Q+1) .EQ. 0.0D+00) GO TO 140
  120 CONTINUE
C     ********** FIND VECTORS BY INVERSE ITERATION **********
  140 TAG = TAG + 1
      IQMP = Q - P + 1
      S = 0
C
      DO 660 R = 1, M
      IF (IND(R) .NE. TAG) GO TO 660
      ITS = 1
      X1 = W(R)
      IF (S .NE. 0) GO TO 220
C     ********** CHECK FOR ISOLATED ROOT **********
      XU = 1.0D+00
      IF (P .NE. Q) GO TO 160
      RV6(P) = 1.0D+00
      GO TO 600
  160 NORM = ABS(D(P))
C
      DO 180 I = IP, Q
  180 NORM = NORM + ABS(D(I)) + ABS(E(I))
C     ********** EPS2 IS THE CRITERION FOR GROUPING,
C                EPS3 REPLACES ZERO PIVOTS AND EQUAL
C                ROOTS ARE MODIFIED BY EPS3,
C                EPS4 IS TAKEN VERY SMALL TO AVOID OVERFLOW **********
      EPS2 = 1.0D-03 * NORM
      EPS3 = MACHEP * NORM
      UK = IQMP
      EPS4 = UK * EPS3
      UK = EPS4 / SQRT(UK)
      S = P
  200 GROUP = 0
      GO TO 240
C     ********** LOOK FOR CLOSE OR COINCIDENT ROOTS **********
  220 IF (ABS(X1-X0) .GE. EPS2) GO TO 200
      GROUP = GROUP + 1
      IF (ORDER * (X1 - X0) .LE. 0.0D+00) X1 = X0 + ORDER * EPS3
C     ********** ELIMINATION WITH INTERCHANGES AND
C                INITIALIZATION OF VECTOR **********
  240 V = 0.0D+00
C
      DO 300 I = P, Q
      RV6(I) = UK
      IF (I .EQ. P) GO TO 280
      IF (ABS(E(I)) .LT. ABS(U)) GO TO 260
C     ********** WARNING -- A DIVIDE CHECK MAY OCCUR HERE IF
C                E2 ARRAY HAS NOT BEEN SPECIFIED CORRECTLY **********
      XU = U / E(I)
      RV4(I) = XU
      RV1(I-1) = E(I)
      RV2(I-1) = D(I) - X1
      RV3(I-1) = 0.0D+00
      IF (I .NE. Q) RV3(I-1) = E(I+1)
      U = V - XU * RV2(I-1)
      V = -XU * RV3(I-1)
      GO TO 300
  260 XU = E(I) / U
      RV4(I) = XU
      RV1(I-1) = U
      RV2(I-1) = V
      RV3(I-1) = 0.0D+00
  280 U = D(I) - X1 - XU * V
      IF (I .NE. Q) V = E(I+1)
  300 CONTINUE
C
      IF (U .EQ. 0.0D+00) U = EPS3
      RV1(Q) = U
      RV2(Q) = 0.0D+00
      RV3(Q) = 0.0D+00
C     ********** BACK SUBSTITUTION
C                FOR I=Q STEP -1 UNTIL P DO -- **********
  320 DO 340 II = P, Q
      I = P + Q - II
      RV6(I) = (RV6(I) - U * RV2(I) - V * RV3(I)) / RV1(I)
      V = U
      U = RV6(I)
  340 CONTINUE
C     ********** ORTHOGONALIZE WITH RESPECT TO PREVIOUS
C                MEMBERS OF GROUP **********
      IF (GROUP .EQ. 0) GO TO 400
      J = R
C
      DO 380 JJ = 1, GROUP
  360 J = J - 1
      IF (IND(J) .NE. TAG) GO TO 360
      XU = DDOT(IQMP,RV6(P),1,Z(P,J),1)
C
      CALL DAXPY(IQMP,-XU,Z(P,J),1,RV6(P),1)
C
  380 CONTINUE
C
  400 NORM = 0.0D+00
C
      DO 420 I = P, Q
  420 NORM = NORM + ABS(RV6(I))
C
      IF (NORM .GE. 1.0D+00) GO TO 560
C     ********** FORWARD SUBSTITUTION **********
      IF (ITS .EQ. 5) GO TO 540
      IF (NORM .NE. 0.0D+00) GO TO 440
      RV6(S) = EPS4
      S = S + 1
      IF (S .GT. Q) S = P
      GO TO 480
  440 XU = EPS4 / NORM
C
      DO 460 I = P, Q
  460 RV6(I) = RV6(I) * XU
C     ********** ELIMINATION OPERATIONS ON NEXT VECTOR
C                ITERATE **********
  480 DO 520 I = IP, Q
      U = RV6(I)
C     ********** IF RV1(I-1) .EQ. E(I), A ROW INTERCHANGE
C                WAS PERFORMED EARLIER IN THE
C                TRIANGULARIZATION PROCESS **********
      IF (RV1(I-1) .NE. E(I)) GO TO 500
      U = RV6(I-1)
      RV6(I-1) = RV6(I)
  500 RV6(I) = U - RV4(I) * RV6(I-1)
  520 CONTINUE
C
      ITS = ITS + 1
      GO TO 320
C     ********** SET ERROR -- NON-CONVERGED EIGENVECTOR **********
  540 IERR = -R
      XU = 0.0D+00
      GO TO 600
C     ********** NORMALIZE SO THAT SUM OF SQUARES IS
C                1 AND EXPAND TO FULL ORDER **********
  560 U = 0.0D+00
C
      DO 580 I = P, Q
      RV6(I) = RV6(I) / NORM
  580 U = U + RV6(I)**2
C
      XU = 1.0D+00 / SQRT(U)
C
  600 DO 620 I = 1, N
  620 Z(I,R) = 0.0D+00
C
      DO 640 I = P, Q
  640 Z(I,R) = RV6(I) * XU
C
      X0 = X1
  660 CONTINUE
C
      IF (Q .LT. N) GO TO 100
  680 RETURN
C     ********** LAST CARD OF TINVIT **********
      END
      SUBROUTINE IMTQLV(N,D,E,E2,W,IND,IERR,RV1)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER TAG
      DOUBLE PRECISION MACHEP
      DIMENSION D(N),E(N),E2(N),W(N),RV1(N),IND(N)
C
C     THIS ROUTINE IS A VARIANT OF  IMTQL1  WHICH IS A TRANSLATION OF
C     ALGOL PROCEDURE IMTQL1, NUM. MATH. 12, 377-383(1968) BY MARTIN AND
C     WILKINSON, AS MODIFIED IN NUM. MATH. 15, 450(1970) BY DUBRULLE.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 241-248(1971).
C
C     THIS ROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC TRIDIAGONAL
C     MATRIX BY THE IMPLICIT QL METHOD AND ASSOCIATES WITH THEM
C     THEIR CORRESPONDING SUBMATRIX INDICES.
C
C     ON INPUT-
C
C        N IS THE ORDER OF THE MATRIX,
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX,
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
C          IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY,
C
C        E2 CONTAINS THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
C          E2(1) IS ARBITRARY.
C
C     ON OUTPUT-
C
C        D AND E ARE UNALTERED,
C
C        ELEMENTS OF E2, CORRESPONDING TO ELEMENTS OF E REGARDED
C          AS NEGLIGIBLE, HAVE BEEN REPLACED BY ZERO CAUSING THE
C          MATRIX TO SPLIT INTO A DIRECT SUM OF SUBMATRICES.
C          E2(1) IS ALSO SET TO ZERO,
C
C        W CONTAINS THE EIGENVALUES IN ASCENDING ORDER.  IF AN
C          ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT AND
C          ORDERED FOR INDICES 1,2,...IERR-1, BUT MAY NOT BE
C          THE SMALLEST EIGENVALUES,
C
C        IND CONTAINS THE SUBMATRIX INDICES ASSOCIATED WITH THE
C          CORRESPONDING EIGENVALUES IN W -- 1 FOR EIGENVALUES
C          BELONGING TO THE FIRST SUBMATRIX FROM THE TOP,
C          2 FOR THOSE BELONGING TO THE SECOND SUBMATRIX, ETC.,
C
C        IERR IS SET TO
C          ZERO       FOR NORMAL RETURN,
C          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
C                     DETERMINED AFTER 30 ITERATIONS,
C
C        RV1 IS A TEMPORARY STORAGE ARRAY.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
C     ********** MACHEP IS A MACHINE DEPENDENT PARAMETER SPECIFYING
C                THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.
C
C                **********
      MACHEP = 2.0D+00**(-50)
C
      IERR = 0
      K = 0
      TAG = 0
C
      DO 100 I = 1, N
      W(I) = D(I)
      IF (I .NE. 1) RV1(I-1) = E(I)
  100 CONTINUE
C
      E2(1) = 0.0D+00
      RV1(N) = 0.0D+00
C
      DO 360 L = 1, N
      J = 0
C     ********** LOOK FOR SMALL SUB-DIAGONAL ELEMENT **********
  120 DO 140 M = L, N
      IF (M .EQ. N) GO TO 160
      IF (ABS(RV1(M)) .LE. MACHEP * (ABS(W(M)) + ABS(W(M+1)))) GO TO
     +     160
C     ********** GUARD AGAINST UNDERFLOWED ELEMENT OF E2 **********
      IF (E2(M+1) .EQ. 0.0D+00) GO TO 180
  140 CONTINUE
C
  160 IF (M .LE. K) GO TO 200
      IF (M .NE. N) E2(M+1) = 0.0D+00
  180 K = M
      TAG = TAG + 1
  200 P = W(L)
      IF (M .EQ. L) GO TO 280
      IF (J .EQ. 30) GO TO 380
      J = J + 1
C     ********** FORM SHIFT **********
      G = (W(L+1) - P) / (2.0D+00 * RV1(L))
      R = SQRT(G*G+1.0D+00)
      G = W(M) - P + RV1(L) / (G + SIGN(R,G))
      S = 1.0D+00
      C = 1.0D+00
      P = 0.0D+00
      MML = M - L
C     ********** FOR I=M-1 STEP -1 UNTIL L DO -- **********
      DO 260 II = 1, MML
      I = M - II
      F = S * RV1(I)
      B = C * RV1(I)
      IF (ABS(F) .LT. ABS(G)) GO TO 220
      C = G / F
      R = SQRT(C*C+1.0D+00)
      RV1(I+1) = F * R
      S = 1.0D+00 / R
      C = C * S
      GO TO 240
  220 S = F / G
      R = SQRT(S*S+1.0D+00)
      RV1(I+1) = G * R
      C = 1.0D+00 / R
      S = S * C
  240 G = W(I+1) - P
      R = (W(I) - G) * S + 2.0D+00 * C * B
      P = S * R
      W(I+1) = G + P
      G = C * R - B
  260 CONTINUE
C
      W(L) = W(L) - P
      RV1(L) = G
      RV1(M) = 0.0D+00
      GO TO 120
C     ********** ORDER EIGENVALUES **********
  280 IF (L .EQ. 1) GO TO 320
C     ********** FOR I=L STEP -1 UNTIL 2 DO -- **********
      DO 300 II = 2, L
      I = L + 2 - II
      IF (P .GE. W(I-1)) GO TO 340
      W(I) = W(I-1)
      IND(I) = IND(I-1)
  300 CONTINUE
C
  320 I = 1
  340 W(I) = P
      IND(I) = TAG
  360 CONTINUE
C
      GO TO 400
C     ********** SET ERROR -- NO CONVERGENCE TO AN
C                EIGENVALUE AFTER 30 ITERATIONS **********
  380 IERR = L
  400 RETURN
C     ********** LAST CARD OF IMTQLV **********
      END
C*MODULE BLAS1   *DECK DDOT
      DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(*),DY(*)
C
C     FORMS THE DOT PRODUCT OF TWO VECTORS.
C           DOT = DX(I) * DY(I)
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DDOT = 0.0D+00
      DTEMP = 0.0D+00
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DTEMP = DTEMP + DX(IX)*DY(IY)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      DDOT = DTEMP
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DTEMP = DTEMP + DX(I)*DY(I)
   30 CONTINUE
      IF( N .LT. 5 ) GO TO 60
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DTEMP = DTEMP + DX(I)*DY(I) + DX(I + 1)*DY(I + 1) +
     *   DX(I + 2)*DY(I + 2) + DX(I + 3)*DY(I + 3) + DX(I + 4)*DY(I + 4)
   50 CONTINUE
   60 DDOT = DTEMP
      RETURN
      END
C*MODULE BLAS1   *DECK DROT
      SUBROUTINE  DROT (N,DX,INCX,DY,INCY,C,S)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(*),DY(*)
C
C     APPLIES A PLANE ROTATION.
C           DX(I) =  C*DX(I) + S*DY(I)
C           DY(I) = -S*DX(I) + C*DY(I)
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C       CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS NOT EQUAL
C         TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DTEMP = C*DX(IX) + S*DY(IY)
        DY(IY) = C*DY(IY) - S*DX(IX)
        DX(IX) = DTEMP
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C       CODE FOR BOTH INCREMENTS EQUAL TO 1
C
   20 DO 30 I = 1,N
        DTEMP = C*DX(I) + S*DY(I)
        DY(I) = C*DY(I) - S*DX(I)
        DX(I) = DTEMP
   30 CONTINUE
      RETURN
      END
C*MODULE BLAS1   *DECK DAXPY
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(*),DY(*)
C
C     CONSTANT TIMES A VECTOR PLUS A VECTOR.
C           DY(I) = DY(I) + DA * DX(I)
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      IF(N.LE.0)RETURN
      IF (DA .EQ. 0.0D+00) RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DY(IY) + DA*DX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,4)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DY(I) = DY(I) + DA*DX(I)
   30 CONTINUE
      IF( N .LT. 4 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,4
        DY(I) = DY(I) + DA*DX(I)
        DY(I + 1) = DY(I + 1) + DA*DX(I + 1)
        DY(I + 2) = DY(I + 2) + DA*DX(I + 2)
        DY(I + 3) = DY(I + 3) + DA*DX(I + 3)
   50 CONTINUE
      RETURN
      END
C*MODULE BLAS1   *DECK DSWAP
      SUBROUTINE  DSWAP (N,DX,INCX,DY,INCY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(*),DY(*)
C
C     INTERCHANGES TWO VECTORS.
C           DX(I) <==> DY(I)
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C       CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS NOT EQUAL
C         TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DTEMP = DX(IX)
        DX(IX) = DY(IY)
        DY(IY) = DTEMP
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C       CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C       CLEAN-UP LOOP
C
   20 M = MOD(N,3)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DTEMP = DX(I)
        DX(I) = DY(I)
        DY(I) = DTEMP
   30 CONTINUE
      IF( N .LT. 3 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,3
        DTEMP = DX(I)
        DX(I) = DY(I)
        DY(I) = DTEMP
        DTEMP = DX(I + 1)
        DX(I + 1) = DY(I + 1)
        DY(I + 1) = DTEMP
        DTEMP = DX(I + 2)
        DX(I + 2) = DY(I + 2)
        DY(I + 2) = DTEMP
   50 CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     MODULE for reading unformated file.
C
C     These routines are taken directly from Mike Frisch's rdmat1.F 
C     program and modified to actually use the integrals rather than
C     just report the result of reading them. The changes are in full
C     capital letters.
C
C     Mike's code allows for 4 byte and 2 byte integral indices for
C     the integrals as well as 8 byte integers, but only 8 byte has
C     been tested.
C 
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
*Deck READ1EGAU
      Subroutine Read1EGAU(IOut,IU,CBuf,NBasis,Len12L,MaxBuf,IBuf,IBuf4,
     $  Buf,MaxNTT,X,Done,EOF,LPRINT,LDIP)
      Implicit Real*8(A-H,O-Z)
C
C     Read one 1e matrix from the unformatted matrix element file.
C
C     Name changed from READ1E to avoid clash with VB2000 routine.
C
      Character*(*) CBuf
      Logical Done, EOF,LPRINT,LDIP
      Dimension IBuf(*), Buf(*), X(*)
      Integer*4 IBuf4(*), NI4, NR4, NTot4, LenBu4, N14, N24, N34, N44,
     $  N54
      Save Zero
      Data Zero/0.0d0/
 1000 Format(' Label ',A,' NI=',I2,' NR=',I2,' NTot=',I8,' LenBuf=',I8,
     $  ' N=',5I6)
 1001 Format(' Reading ',A,' NI=',I2,' NR=',I2,' NTot=',I8,
     & ' LenBuf=',I8)
 1010 Format(1X,I1,' Matrix parameter out of range:  L=',I8,' MaxNTT=',
     $  I3,'.')
 1020 Format(' Read1EGAU does not understand this type of matrix.')
 1030 Format(1X,A,', matrix',I6,':')
 1040 Format(1X,5F20.8)
 1050 Format(' NI=',I6,' LenBuf=',I10,' but MaxBuf=',I10,'.')
C
      If(Len12L.eq.4) then
        Read(IU,End=900) CBuf, NI4, NR4, NTot4, LenBu4, N14, N24, N34,
     $    N44, N54
        NI = NI4
        NR = NR4
        NTot = NTot4
        LenBuf = LenBu4
        N1 = N14
        N2 = N24
        N3 = N34
        N4 = N44
        N5 = N54
      else
        Read(IU,End=900) CBuf, NI, NR, NTot, LenBuf, N1, N2, N3, N4, N5
      endIf
      Done = CBuf(1:3).eq.'REG'.or.CBuf(1:3).eq.'RAF'
      EOF = .False.
      If(Done) then
        Backspace IU
        Return
        endIf
      IF(LPRINT)
     &Write(IOut,1000) CBuf, NI, NR, NTot, LenBuf, N1, N2, N3, N4, N5
      IF (CBUF(1:7).EQ."OVERLAP"
     &  .OR.CBUF(1:18).EQ."CORE HAMILTONIAN A") THEN
          IF(.NOT.LDIP) Write(IOut,1001) CBuf(1:25),NI,NR,NTot,LenBuf
      ENDIF
      IF (LDIP. AND.CBUF(1:6).EQ."DIPOLE")
     & Write(IOut,1001) CBuf(1:25), NI, NR, NTot, LenBuf
      If(NI.eq.1.and.NR.eq.1.and.N2.eq.1.and.N3.eq.1.and.N4.eq.1
     $  .and.N5.eq.1) then
        If(N1.gt.MaxNTT) then
          Write(IOut,1010) 1, N1, MaxNTT
          Stop
          endIf
        Call Rd1EAI(IOut,IU,N1,NTot,Len12L,LenBuf,IBuf,IBuf4,Buf,X)
        Lim = 1
        Do 10 I = 2, N1
          If(X(I).ne.Zero) Lim = I
   10     Continue
      IF(LPRINT)
     &  Write(IOut,1040) (X(I),I=1,Lim)
      else if(NI.ne.0.and.NR.eq.0) then
        If((NI*LenBuf).gt.MaxBuf) then
          Write(IOut,1050) NI, LenBuf, MaxBuf
          Stop
          endIf
        Call RdNI(IOut,Len12L,IU,NI,NTot,LenBuf,IBuf,IBuf4)
      else if(NI.ne.0.or.NR.ne.1.or.LenBuf.gt.MaxBuf.or.
     $  (NR*NTot).gt.MaxNTT) then
        Write(IOut,1010) 2, NR*NTot, MaxNTT
        Stop
      else
        Call Rd1EA(IU,NTot,LenBuf,Buf,X)
        N3A = N3
        If(N3.eq.0) N3A = 1
        N4A = N4
        If(N4.eq.0) N4A = 1
        N5A = N5
        If(N5.eq.0) N5A = 1
        N345 = N3A*N4A*N5A
        LCB = 1
        Do 5 I = 2, Len(CBuf)
          If(CBuf(I:I).ne.' ') LCB = I
    5     Continue
        If(N1.eq.(-N2)) then
          N1A = IAbs(N1)
          NTT = (N1A*(N1A+1))/2
          If(NTot.eq.(NTT*N345)) then
            Ind = 1
            Do 110 I = 1, N345
              If(N3.gt.1.AND.LPRINT) Write(IOut,1030) CBuf(1:LCB), I
              IF(LPRINT) Call LTOut(IOut,NBasis,X(Ind),0)
  110         Ind = Ind + NTT
          else
            Write(IOut,1020)
            endIf
        else
          N2A = N2
          If(N2.eq.0) N2A = 1
          N12 = N1*N2A
          If(NTot.eq.(N12*N345)) then
            Ind = 1
            Do 120 I = 1, N345
              If(N3A.gt.1.AND.LPRINT) Write(IOut,1030) CBuf(1:LCB), I
              IF(LPRINT) Call RecOut(IOut,0,N1,N2A,X(Ind))
  120         Ind = Ind + N12
          else
            Write(IOut,1020)
            endIf
          endIf
        endIf
      Return
  900 Done = .True.
      EOF = .True.
      Return
      End
*Deck LTOUT
      Subroutine LTOut(IOut,N,A,Key)
      Implicit Real*8(A-H,O-Z)
C
C     Working precision routine to print out the lower triangular part
C     of a symmetric matrix stored in compressed lower triangular form.
C
C        N         Dimension of matrix.
C        A         Array to be printed.
C        KEY    N<=0 ... Suppress elements with absolute values less
C                        than 10**(-6+N)
C                  1 ... Print complete matrix.
C
      Parameter (NumCol=5)
      Dimension A(*), S(NumCol)
 2001 Format(5(11X,I3))
 2003 Format(I4,9D14.6)
      LInd(I,J) = (Max0(I,J)*(Max0(I,J)-1)/2) + Min0(I,J)
C
      Zero = 0
      If(Key.gt.0) then
        Thresh = Zero
      else
        Thresh = 10.0d0**(Key-6)
        endIf
      Do 20 IStart = 1, N, NumCol
        IEnd = Min0(IStart+NumCol-1,N)
        Write(IOut,2001) (IR,IR=IStart,IEnd)
        Do 20 IRow = IStart, N
          IRange = Min0(IRow-IStart+1,NumCol)
          L = LInd(IRow,IStart)
          Do 10 I = 1, IRange
            S(I) = A(L+I-1)
            If(Abs(S(I)).lt.Thresh) S(I) = Zero
   10       Continue
          Write(IOut,2003) IRow, (S(I),I=1,IRange)
   20     Continue
      Return
      End
*Deck RD1EA
      Subroutine Rd1EA(IU,NTot,LenBuf,Buf,X)
      Implicit Real*8(A-H,O-Z)
      Dimension Buf(LenBuf), X(*)
C
      Do 20 Ind = 0, (NTot-1), LenBuf
        NDo = Min(LenBuf,NTot-Ind)
        Read(IU) Buf
        Do 10 I = 1, NDo
   10     X(Ind+I) = Buf(I)
   20   Continue
      Return
      End
*Deck RD1EAI
      Subroutine Rd1EAI(IOut,IU,N1,NTot,Len12L,LenBuf,IBuf,IBuf4,Buf,X)
      Implicit Real*8(A-H,O-Z)
      Dimension IBuf(LenBuf), Buf(LenBuf), X(*)
      Integer*4 IBuf4(LenBuf)
      Save Zero
      Data Zero/0.0d0/
 1000 Format(' Ind=',I6,' I=',I6,' IBuf(I)=',I6,' out of range, N=',I6,
     $  '.')
C
      Do 10 I = 1, N1
   10   X(I) = Zero
      Do 40 Ind = 0, (NTot-1), LenBuf
        NDo = Min(LenBuf,NTot-Ind)
        If(Len12L.eq.4) then
          Read(IU) IBuf4, Buf
          Do 20 I = 1, NDo
   20       IBuf(I) = IBuf4(I)
        else
          Read(IU) IBuf, Buf
          endIf
        Do 30 I = 1, NDo
          If(IBuf(I).lt.1.or.IBuf(I).gt.N1) then
            Write(IOut,1000) Ind, I, IBuf(I), N1
            Stop
            endIf
   30     X(IBuf(I)) = Buf(I)
   40   Continue
      Return
      End
*Deck READ2EGAU
      Subroutine Read2EGAU(IOut,IU,EOF,Len12L,Len4L,CBuf,MaxBuf,
     $  MaxNR,ID,ID2,ID4,DX,G)
C
C     Routine renamed from Read2E to avoid clash with VB2000 routine
C
C     Now has array G as argument.
C
      Implicit Real*8(A-H,O-Z)
      Character*(*) CBuf
      Logical EOF
      Dimension ID(4,*), DX(*), G(*)
      Integer*2 ID2(4,*)
      Integer*4 ID4(4,*), NI4, NR4, NTot4, LenBu4
 1000 Format(' Reading ',A,' NI=',I2,' NR=',I2,' NTot=',I10,
     & ' LenBuf=',I8)
 1010 Format(' Matrix parameter out of range.')
 1020 Format(' No 2E integrals in file.')
C
      If(EOF) goto 900
   10 If(Len12L.eq.4) then
        Read(IU,End=900) CBuf, NI4, NR4, NTot4, LenBu4
        NI = NI4
        NR = NR4
        NTot = NTot4
        LenBuf = LenBu4
      else
        Read(IU,End=900) CBuf, NI, NR, NTot, LenBuf
        endIf
      Write(IOut,1000) CBuf(1:25), NI, NR, NTot, LenBuf
      If(CBuf(1:3).eq.'REG') then
        ISMode = 0
        NRT = 1
      else if(CBuf(1:3).eq.'RAF') then
        ISMode = NR
        NRT = 3
        CALL ABRTG(" RAFFENETTI integtrals not allowed")
      else
        NSkip = (NTot+LenBuf-1)/LenBuf
        Do 20 I = 1, NSkip
          Read(IU)
   20     Continue
        Goto 10
        endIf
      If(NI.ne.4.or.NR.lt.1.or.NR.gt.NRT.or.NR.gt.MaxNR
     $  .or.LenBuf.gt.MaxBuf) then
        Write(IOut,1010)
        Stop
        endIf
      Call Rd2EA(IOut,IU,Len4L,NTot,ISMode,NR,LenBuf,ID,ID2,ID4,DX,G)
      Return
  900 Write(IOut,1020)
      Return
      End
*Deck RD2EA
      Subroutine Rd2EA(IOut,IU,Len4L,NTot,ISMode,NR,LB,ID,ID2,ID4,DX,G)
C
C     Modified from Mike Frisch's version by adding argument G as
C     array to store integrals and them write them to VB2000 unit
C     IAO2E. Changes are fully capitalised.
C
      Implicit Real*8(A-H,O-Z)
      Dimension ID(4,LB), DX(NR,LB), G(*)
      INTEGER INDIJ(1000),INDKL(1000),IAO2E,LBUFF
      COMMON /INTS/ LBUFF
      Integer*2 ID2(4,LB)
      Integer*4 ID4(4,LB)
C1020 Format(' I=',I3,' J=',I3,' K=',I3,' L=',I3,' Int=',D20.12)
C1030 Format(' I=',I3,' J=',I3,' K=',I3,' L=',I3,' R1=',D20.12)
C1040 Format(' I=',I3,' J=',I3,' K=',I3,' L=',I3,' R1=',D20.12,
C    $       ' R2=',D20.12)
C1050 Format(' I=',I3,' J=',I3,' K=',I3,' L=',I3,' R1=',D20.12,
C    $       ' R2=',D20.12,' R3=',D20.12)
C1021 FORMAT(' IJ=',I9,' KL=',I9,' Int=',D20.12)
C
      LBUFF = LB
      CALL GETIOUNIT('IAO2E   ',IAO2E)
      Do 100 Ind = 1, NTot, LB
        NDo = Min(LB,NTot-Ind+1)
        If(Len4L.eq.2) then
          Read(IU) ID2, DX
          Do 10 I = 1, NDo
            ID(1,I) = ID2(1,I)
            ID(2,I) = ID2(2,I)
            ID(3,I) = ID2(3,I)
   10       ID(4,I) = ID2(4,I)
        else if(Len4L.eq.4) then
          Read(IU) ID4, DX
          Do 20 I = 1, NDo
            ID(1,I) = ID4(1,I)
            ID(2,I) = ID4(2,I)
            ID(3,I) = ID4(3,I)
   20       ID(4,I) = ID4(4,I)
        else
          Read(IU) ID, DX
          endIf
C       If(ISMode.eq.0) then
C         Write(IOut,1020) ((ID(J,I),J=1,4),DX(1,I),I=1,NDo)
C       else if(ISMode.eq.1) then
C         Write(IOut,1030) ((ID(J,I),J=1,4),DX(1,I),I=1,NDo)
C       else if(ISMode.eq.2) then
C         Write(IOut,1040) ((ID(J,I),J=1,4),DX(1,I),DX(2,I),I=1,NDo)
C       else
C         Write(IOut,1050) ((ID(J,I),J=1,4),DX(1,I),DX(2,I),DX(3,I),
C    $      I=1,NDo)
C       endIf
        DO I=1,NDO
          G(I) = DX(1,I)
          I1 = ID(1,I)
          I2 = ID(2,I)
          I3 = ID(3,I)
          I4 = ID(4,I)
          IF(I1.GE.I2) THEN
            II12 = I1*(I1-1)/2 + I2
          ELSE
            II12 = I2*(I2-1)/2 + I1
          END IF
          IF(I3.GE.I4) THEN
            II34 = I3*(I3-1)/2 + I4
          ELSE
            II34 = I4*(I4-1)/2 + I3
          END IF
          IF(II12.GE.II34) THEN
            INDIJ(I) = II12
            INDKL(I) = II34
          ELSE
            INDIJ(I) = II34
            INDKL(I) = II12
          END IF
C         WRITE(IOUT,1021) INDIJ(I),INDKL(I),G(I)
        ENDDO
        CALL PUT2E(G,INDIJ,INDKL,NDO,LB,IAO2E)
  100   Continue
      M0 = 0
      CALL PUT2E(G,INDIJ,INDKL,M0,LB,IAO2E)
C     WRITE(IOUT,'(" IAO2E=",I8)') IAO2E
      REWIND(IAO2E)
      Return
      End
*Deck RECOUT
      Subroutine RecOut(IOut,ISmall,M,N,X)
      Implicit Real*8(A-H,O-Z)
C
C     Print matrix X.  ISmall is >0 to print all elements, <=0 to
C     print elements greater than 10**(Key-6).
C
      Parameter (NumCol=5)
      Dimension X(M,N), Y(NumCol)
      Save Zero, Ten
      Data Zero/0.0d0/, Ten/10.0d0/
 1030 Format(I7,1X,5F20.8)
 1040 Format(1X,8(13X,I6,1X))
C
      Small = Ten**(ISmall-6)
      Do 100 ILower = 1, N, NumCol
        IUpper = Min(ILower+NumCol-1,N)
        Num = IUpper - ILower + 1
        Write(IOut,1040) (I,I=ILower,IUpper)
        Do 90 I = 1, M
          Do 10 J = ILower, IUpper
   10       Y(J-ILower+1) = X(I,J)
          Do 20 J = 1, Num
            If(Abs(Y(J)).lt.Small) Y(J) = Zero
   20       Continue
          Write(IOut,1030) I, (Y(J),J=1,Num)
   90     Continue
  100   Continue
      Return
      End
*Deck RDNI
      Subroutine RdNI(IOut,Len12L,IU,NI,NTot,LenBuf,IBuf,IBuf4)
      Implicit Real*8(A-H,O-Z)
      Dimension IBuf(NI,LenBuf)
      Integer*4 IBuf4(NI,LenBuf)
 1000 Format(' I=',I6,' IVals=',10I20)
C
      Do 30 Ind = 0, (NTot-1), LenBuf
        NDo = Min(LenBuf,NTot-Ind)
        If(Len12L.eq.4) then
          Read(IU) IBuf4
          Do 10 I = 1, NDo
            Write(IOut,1000) I+Ind, (IBuf4(J,I),J=1,NI)
   10       Continue
        else
          Read(IU) IBuf
          Do 20 I = 1, NDo
            Write(IOut,1000) I+Ind, (IBuf(J,I),J=1,NI)
   20       Continue
          endIf
   30   Continue
      Return
      End
      SUBROUTINE SWAP(I,J)
      IMPLICIT NONE
      INTEGER I,J,L
C     GAMESS ALREADY HAS THIS in CIMI.SRC SO NEEDED HERE
      L=I
      I=J
      J=L
      END

